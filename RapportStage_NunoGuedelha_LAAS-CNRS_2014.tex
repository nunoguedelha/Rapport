\documentclass{report}

%Packages pour les langues
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{lmodern}

%Package pour la mise en forme (marges)
\usepackage[a4paper]{geometry}
\geometry{hscale=0.85,vscale=0.85,centering}
\usepackage{layouts} %affichage des largeurs de zone texte
\usepackage{parallel}
\usepackage{setspace}
\usepackage{wrapfig}
%Packages pour les liens dynamiques
\usepackage{hyperref}
\usepackage{multicol}
%\usepackage{underscore}

%Packages pour les formules de Maths
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{pseudocode}
\usepackage{fancybox}

%Packages des images
\usepackage{graphicx}
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}

%\usepackage{subfigure}
\usepackage{subfig}
\usepackage{wrapfig}
\usepackage{caption}

%\usepackage{subcaption}
\usepackage{float}

%Packages pour le glossaire
\usepackage{glossaries}

%\usepackage[xindy]{glossaries}
\makeglossaries

%Package pour colorier le code Matlab (copyright Jérémy Fauvel)
\usepackage{listings}
\usepackage[usenames,dvipsnames]{color}

%Code pour afficher du code Matlab
\definecolor{MyDarkGreen}{rgb}{0.0,0.4,0.0}
\lstset{language=Matlab, frame=none, basicstyle=\small\ttfamily, keywordstyle=[1]\color{Blue}\bfseries, keywordstyle=[2]\color{Purple}, keywordstyle=[3]\color{Blue}\underbar, identifierstyle=, commentstyle=\usefont{T1}{pcr}{m}{sl}\color{MyDarkGreen}\small, stringstyle=\color{Purple}, showstringspaces=false, tabsize=5, morekeywords={xlim,ylim,var,alpha,factorial,poissrnd,normpdf,normcdf}, morekeywords=[2]{on, off, interp}, morekeywords=[3]{FindESS, homework_example}, morecomment=[l][\color{Blue}]{...}, numbers=left, firstnumber=1, numberstyle=\tiny\color{Red}, stepnumber=1}

%Packages pour les string
\usepackage{xstring}

%Packages pour les listes
%\usepackage{enumitem}
\usepackage{moreverb}



\begin{document}

%%%%%%%%%%%%%%%%%% page de couverture %%%%%%%%%%%%%%%%%%%

\input{./tex/pageCouverture.tex}

%\begin{titlepage}
%\title{Rapport de stage - IRR \\ Implémentation et application d'un algorithme dynamique hybride pour le contrôle d'articulations flexibles}
%\date{3 Mars 2014 - 31 Août 2014}
%\author{Auteur: \bsc{Guedelha} Nuno \\ Tuteur: \bsc{Stasse} Olivier}
%\end{titlepage}

\setcounter{secnumdepth}{3}

\graphicspath{{illustrations/}}
%\maketitle

%Rennomer la table des matières en Sommaire
\renewcommand{\contentsname}{Sommaire}
\tableofcontents
\listoffigures

%%%%%%%%%%%%%%%%%% Macros %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{./tex/macros.tex}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Remerciements}
\addcontentsline{toc}{chapter}{Remerciements}

Je voudrais remercier, avant tout, tous ceux qui ont rendu cette expérience possible, et très enrichissante.\\
Je tiens à remercier dans un premier temps, toute l’équipe pédagogique du Master I.R.R. et les intervenants professionnels responsables de la formation, pour avoir assuré la partie académique de celle-ci. Je remercie Mme. Viviane Cadenat et M. Michel Taix pour leurs conseils sur les critères de choix d'une formation de 2ème cycle en Robotique, qui ont facilité mon orientation à l'origine de mon inscription en Master I.R.R.\\
Je remercie également Monsieur Vincent Durola, mon tuteur pédagogique attitré, pour ses conseils concernant la mission de ce stage, conseils qui m'ont permis de prendre du recul par rapport à mes tâches et aux différents aspects techniques.\\
Je tiens à remercier tout particulièrement et à témoigner toute ma reconnaissance aux membres de l'équipe Gepetto, pour l’expérience enrichissante qu’elles m’ont permis de vivre durant ces six mois au sein du LAAS :\\
Monsieur Olivier Stasse, pour m’avoir intégré rapidement au sein du laboratoire et m’avoir accordé toute sa confiance ; pour le temps qu’il m’a consacré tout au long de cette période, sachant répondre à toutes mes interrogations ; sans oublier sa participation au cheminement de ce rapport.\\
Monsieur Jean Paul Laumond, Maximilien Naveau, Justin Carpentier, ainsi que l’ensemble des membres de l'équipe Gepetto pour leur accueil sympathique et leur coopération professionnelle tout au long de ces six mois.\\
Tous ceux qui ont délivré des formations techniques sur la planification de mouvements, la dynamique inverse et les algorithmes de contrôle.\\

\vspace{0.3cm} % retour à la ligne

%%%%%%%%%%%%%%%%%% glossaire %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{./tex/glossaire.tex}


\glsaddall
\printglossaries

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

\section*{contexte}

\'{E}tudiant en deuxième année de Master de Robotique (IRR) à Paul Sabatier, j'ai effectué mon stage de fin d'année au Laboratoire d'Analyse et d'Architecture des Systèmes, au sein de l'équipe Gepetto, sous la responsabilité de Olivier Stasse, chargé de recherche, au coeur du thème de la robotique humanoïde. Issu d'une formation d'Ingénieur en informatique et télécommunications, et suite à une expérience professionnelle de douze ans, j'ai choisi de reprendre des études pour me spécialiser en Robotique, et pouvoir ainsi explorer ce domaine multidisciplinaire et riche en opportunités d'innovation. Ce qui me motive également c'est de faire un métier dans la recherche, dans un laboratoire ou dans une entreprise en tant qu'ingénieur de recherche. Ces objectifs m'ont amené à suivre le Master I.R.R., qui réunissait toutes les composantes d'une formation équilibrée et complète autour des fonctions robotiques comme la perception, l'intelligence artificielle mais aussi, et surtout, la manipulation et la mobilité. Ces deux derniers points sont au centre de mon intérêt pour la robotique. Je souhaitais développer mes compétences dans le thème de la robotique mobile, plus particulièrement des robots articulés, comme les robots humanoïdes, plus précisément au niveau de la modélisation spatiale et fonctionnelle de ces systèmes, ainsi que le contrôle optimal. Ce domaine est naturellement dans la continuïté de mon expérience dans l'embarqué, le temps réel et l'optimisation. Le LAAS-CNRS m'est alors apparu comme un des meilleurs choix pour effectuer un stage.

\subsection*{Le LAAS ...}
En effet, le CNRS, Centre Nationnal de la Recherche Scientifique, est le principal organisme de recherche à caractère pluridisciplinaire en France, menant des recherches dans l'ensemble des domaines scientifiques, technologiques et sociétaux. Il emploie 33 000 personnes (dont 24 955 statutaires, 11 204 chercheurs et 13 751 ingénieurs, techniciens et administratifs), et bénéficie d'une implantation sur l'ensemble du territoire national, s'appuyant sur plus de 1100 unités de recherche et de service.

Le Laboratoire d’Analyse et d’Architecture des Systèmes (LAAS) est une unité propre du CNRS rattachée à l’Institut des Sciences de l'Ingénierie et des Systèmes (INSIS) et à l'Institut des Sciences de l'Information et de leurs Interactions (INS2I), et est associé à par convention à cinq membres fondateurs de la COMUE \og Université de Toulouse \fg{}, dont l'Université Paul Sabatier (UPS). Le laboratoire a le label \textbf{Institut Carnot}. Avec ses 648 employés dont 509 chercheurs et 247 doctorants, le LAAS mène des recherches en sciences et technologies de l’information, de la communication et des systèmes dans 8 thèmes scientifiques :

\setlength{\columnsep}{10pt}
\begin{multicols}{2}\raggedcolumns
\begin{itemize}
\item Informatique critique
\item Réseaux et communications
\item Robotique
\item Décision et optimisation
\item HF et optique : de l'EM aux systèmes
\item Nano ingénierie et intégration
\item Micro nano bio technologies
\item Gestion de l'énergie
\end{itemize}
\end{multicols}

\noindent
Le laboratoire est à la pointe de la recherche en Robotique, notamment en Robotique humanoïde et dispose de moyens importants pour ses activités de recherche, notamment au sein de l'équipe Gepetto. 

\subsection*{L'équipe Gepetto ...}
Jean-Paul Laumond, roboticien, aujourd'hui directeur de recherche au LAAS-CNRS, a crée en 2006 GEPETTO, une équipe de recherche centrée sur le thème de la robotique humanoïde. De 2005 à 2008, il co-dirige le laboratoire franco-japonais AIST-CNRS JRL en robotique humanoïde. C’est dans ce cadre que le CNRS acquiert le robot humanoïde HRP-2 en 2006. L’activité de recherche de l’équipe Gepetto est aujourd'hui centrée sur l’analyse et la génération de mouvement des systèmes anthropomorphes. Elle est unanimement reconnue pour son expertise dans ce domaine. La difficulté du problème de commande des systèmes anthropomorphes vient de la complexité de leur structure arborescente qui les rend redondants par rapport à la plupart des tâches de positionnement, de l’instabilité naturelle de leur posture bipède, et du sous-actionnement de leurs déplacement dans l’espace. Gepetto étudie ce problème en suivant une approche interdisciplinaire structure en trois niveaux :  fondamental,  d'intégration et applicatif.
\begin{itemize}
\item Le niveau fondamental inclut, entre autres, la modélisation physique du système robotique, la planification de mouvements des éléments de ce système, et la commande locale de ces éléments. Tout cela s'appuie sur des disciplines comme la mécanique, la biomécanique , les neurosciences du mouvement et d'autres disciplines complémentaires.
\item Le niveau d'intégration concerne l'intégration des développements théoriques ou d'outils techniques dans des paquets open source comme des outils de simulation ou des librairies de modélisation dynamique des robots.
\end{itemize}

\section*{problème posé et objectifs ...}

Mon stage s'intègre dans le niveau d'intégration, et plus précisément dans l'intégration de nouveaux algorithmes de modélisation mécanique du robot en vue d'optimiser et rendre plus robuste le contrôle local des différents corps du robot. Ce stage s'insère très bien dans la continuité de ma formation de Master. Celle-ci m'as apporté les concepts fondamentaux et l'application de la modélisation géométrique d'un robot (industriel fixe, ou mobile), ainsi que la modélisation cinématique et dynamique. La modélisation dynamique a abordé le formalisme de Lagrange, qui décrit les équations de mouvement en termes de travail et énergie et exprime l'effort généralisé sur chaque articulation. Ce formalisme serait à priori plus simple que le formalisme de Newton-Euler, qui décrit la dynamique d'un corps rigide en combinant la rotation et la translation. C'est justement le lien exact avec mon sujet de stage, qui explore ce formalisme, qui a été revisité Roy Featherstone, chercheur roboticien à l'IIT, et qui est aujourd'hui intégré dans une librairie open source maintenue par le LAAS.

L'objectif du stage était dans un premier temps d'implémenter un algorithme de dynamique hybride optimal proposé par Roy Featherstone dans son ouvrage “Rigid Body Dynamics Algorithms” \cite{bib_featherstone} et de l'intégrer dans une librairie open source d'algorithmes de dynamique des modèles, \emph{metapod}.

Dans une seconde phase, le but était d'explorer les diverses optimisations supplémentaires proposées dans cet ouvrage, et d'adapter et d'intégrer à \emph{metapod} celles qui apporteraient un réel avantage par rapport aux optimisations natives de librairies de calcul comme \emph{Eigen}. Ces optimisations répondent aux contraintes de puissance de calcul embarquée dans un robot comme HRP2, face aux contraintes de contrôle optimal, prédictif, d'une structure mécanique sous-actionnée.

Finalement, je devais aborder l'application de cet algorithme à la modélisation de systèmes à articulations rotoïdes flexibles, soit juste contraintes par un ressort, soit intégrant un actionnement (simple ou antagoniste) en série avec un système de ressorts suivant diverses configurations possibles.

\section*{étude bibliographique}
Parmi les concepts théoriques à comprendre et à analyser en plus de ce que m'a apporté le Master, l'algèbre spatiale revisitée par Featherstone (chercheur roboticien à l'IIT) dans son ouvrage “Rigid Body Dynamics Algorithms” \cite{bib_featherstone} était le point de départ. Cet ouvrage présente l'ensemble des fondements de l'algèbre spatiale, incluant:

\begin{itemize}
\item la définition des vecteurs spatiaux vitesse, force, accélération, et de l'inertie liés aux corps rigides.
\item l'expression de ses grandeurs dans la base de Plücker spécifique à l'algèbre spatiale, et les transformations de coordonnées
\item l'ensemble des opérations possibles entre les vecteurs spatiaux (addition, produit scalaire, produit vectoriel)
\item la définition des contraintes aux articulations, la modélisation de la dynamique des systèmes multicorps avec la construction de l'équation de mouvement
\item et enfin, la description de l'ensemble des algorithmes de dynamique pour résoudre ces systèmes (Dynamique directe "Forward Dinamics", Dynamique Inverse "Recursive Newton-Euler Algorithm" (RNEA), et la Dynamique Hybride
\end{itemize}

\noindent
le site de Roy Featherstone \cite{bib_featherstoneSite} m'a apporté des compléments très utiles sur l'algèbre spatiale, et aussi sur les algorithmes à travers leur implémentation sous \emph{Matlab}.

Pour mieux situer ces concepts dans le contexte des fondements en mécanique qui m'avaient été enseignés jusqu'ici, j'ai consulté un ouvrage de référence sur la la mécanique solide et des torseurs, à la base même de l'algèbre spatiale: "Mécanique, Fondements et applications" de José-Philippe Pérez \cite{bib_champVecteurs}, professeur émérite de physique de l’Université de Toulouse.

Ce formalisme et les algorithmes de dynamique font souvent appel à des propriétés d'algèbre linéaire, ce qui m'a amené à consulter divers sites internet comme wikipedia et consolider ces informations à l'aide de l'ouvrage "Matrix Computations (Johns Hopkins Studies in the Mathematical Sciences)" de Gene H. Golub., ancien professeur de sciences informatiques à l'université de Stanford, expert reconnu en analyse numérique et algèbre spatiale.

Concernant les aspects techniques autour des outils de calculs et de langage de programmation utilisés, je me suis appuyé sur la documentation technique de la librairie \emph{Eigen} (http://eigen.tuxfamily.org/dox), et de l'ouvrage très complet sur le C++ template et la méta programmation \cite{bib_metaprogramming}.

L'ensemble de ces sources techniques et scientifiques m'ont permis de mener à bien ma mission. Je vous présente dans la suite comment le rapport de cette mission est structuré.

\section*{Structure de ce rapport}
Dans le premier chapitre, je présente les concepts généraux sur la modélisation et les méthodes de contrôle des robots totalement ou sous-actionnés comme les robots humanoïdes. J'en déduit par la suite les contraintes à prendre en compte dans l'intégration de ces méthodes dans la librairie d'algorithmes de dynamique \emph{metapod}.

Inévitablement, le deuxième chapitre se focalise sur les bases d'algèbre spatiale selon le formalisme de Featherstone, indispensables à la compréhension de l'algorithme de Dynamique Hybride à implémenter, ainsi qu'une présentation rapide des algorithmes ré-utilisés. J'explicite également ce que la Dynamique Hybride peut apporter de plus par rapport aux autres algorithme de Dynamique Directe et Inverse.

Naturellement, le troisième chapitre aborde l'implémentation proprement dite, détaillant bien les aspects, théoriques concernant la modélisation mécanique, et techniques concernant son intégration dans l'architecture existante de \emph{metapod}.

Je termine ce chapitre en présentant rapidement:
\begin{itemize}
\item la réflexion que j'ai pu mener avec mon maître de stage sur l'application de la Dynamique Hybride à la modélisation d'articulations flexibles
\item ma recherche de l'état de l'art sur l'utilisation de la Dynamique Hybride au contrôle optimal de systèmes robotiques sous-actionnés.
\end{itemize}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Dynamique et contrôle des systèmes articulés de corps rigides}

\section{Definition des problèmes de Dynamique Directe, Inverse, et Hybride, et applications} \label{ch_concepts_definitions}

Lorsqu'un robot en mouvement est constitués de corps légers, de sorte à ce qu'on puisse négliger leur inertie, le modèle cinétique est suffisant pour modéliser les mouvements du robot ainsi que son contrôle. Par contre, lorsque les parties en mouvement ont une inertie significative ou lorsque le robot n'a pas une base fixe (le moindre mouvement est susceptible de perturber sont appui au sol), il faut tenir compte de la dynamique du système. C'est le cas des mouvements de la marche des robots humanoïdes, dont le contrôle est basé sur le modèle dynamique.

On parle alors de problème de Dynamique Directe ou problème de Dynamique Inverse (respectivement "Forward Dynamics" ou "Inverse Dynamics" dans la littérature internationale). Dans ce rapport, on ne traitera que des systèmes sans boucles dynamiques (le cas par exemple des robots parallèles), aussi désignés comme des arbres cinématiques. En général, pour résoudre le problème dynamique d'un système, on pose une équation de mouvement qui met en relation les grandeurs:

\begin{description}
  \item[$model$ :] le modèle dynamique du système à multi-corps rigides
  \item[$q, \dot{q}, \ddot{q}$ :] vecteurs de position, vitesse, accélération des articulations du système
  \item[$\tau$ :] forces/couples moteurs (internes) appliqués aux articulations
  \item[$f^{ext}$ :] forces de contrainte extérieures (force de gravitation, coriolis, forces de contact, ...)
\end{description}

\subsection{La Dynamique Directe}

La Dynamique directe, souvent appliquée à la simulation, consiste à trouver les accélérations des corps d'un système articulé induites par des forces appliquées aux articulations. Ceci revient à poser l'équation de mouvement suivante, où \textbf{FD} est la fonction donnant les accélérations:

\begin{equation}
\ddot{q} = \mathrm{FD}(model,\mathbf{q,\dot{q},\tau})
\end{equation}

Une des méthodes proposées par Featherstone \cite[(6.2)]{bib_featherstone} passe par le calcul de la matrice $H$ d'Inertie composite du système.  L'algorithme optimal réalisant ce calcul est le CRBA (Composite Rigid Body Algorithm).

\subsection{La Dynamique Inverse}

\`{A} l'opposé, la Dynamique Inverse consiste à déterminer les forces à appliquer aux articulations d'un système pour produire une accélération donnée. Elle peut se résumer à l'équation de mouvement suivante, où \textbf{ID} est la fonction donnant les couples:

\begin{equation}
\mathbf{\tau} = \mathrm{ID}(model,\mathbf{q,\dot{q},\ddot{q}})
\end{equation}

L'algorithme optimal réalisant cette fonction le RNEA (Recursive Newton-Euler Algorithm). La résolution de ce problème s'applique au contrôle optimal d'un système réel dynamique de corps rigides, ou de figures digitales, mais peut aussi être une composante d'un algorithme de Dynamique Directe ou de Dynamique Hybride comme on verra dans le chapitre \ref{ch_impl}. Dans le cas du contrôle optimal, on trouve dans l'état de l'art, plusieurs types de contrôle:
\begin{itemize}
\item le contrôle en couple, plus rare, à cause de la limitation en puissance des moteurs
\item le contrôle en position (cas du HRP2). Dans ce cas, le RNEA servira à filtrer dynamiquement la trajectoire désirée du centre de masse \cite{bib_filtrageTrajectoireCoM}. Cette technique consiste à utiliser, par approximation, la trajectoire désirée du \gls{acr_com} pour calculer le \gls{gls_cop} "réel" du robot, dit "Multi-body CoP" ($CoP^{MB}$) et en déduire la correction à appliquer par le filtre dynamique à la trajectoire du \gls{acr_com}.
\end{itemize}

Je reviendrai rapidement sur cette méthode dans la section \ref{ch_concepts_implEtContr} pour en déduire les contraintes de performance en vitesse d'exécution à tenir compte dans l'implémentation de l'algorithme de Dynamique Hybride.

\subsection{La Dynamique Hybride}

Justement, le problème de Dynamique Hybride est une généralisation de la Dynamique Directe et de la Dynamique Indirecte (\gls{acr_rnea}). En effet, il applique la dynamique directe aux articulations dont on connaît les couples ou forces appliquées, et la dynamique inverse aux articulations dont on connaît les accélérations. Toutes les inconnues sont ainsi résolues. Il est applicable aux cas suivants:

\begin{itemize}
\item simulation de la réponse d'un système articulé ayant soumis à une excitation cinétique sur une des articulations
\item la simplification d'une simulation dynamique de système en supprimant des calculs les articulations au contrôle parfait (couple adaptatif bas niveau permettant d'asservir la position/vitesse/accélération), pour lesquelles un contrôle en position est suffisant. On considère alors les accélérations connues pour ces articulations là.
\item un robot ayant des articulations flexibles, composées par exemple d'un actionneur en série avec un ressort, connues aussi sous le nom de SEA ("Series Elastic Actuator"). Dans ce cas, si on considère qu'un tel système dispose de capteurs de position (encodeurs), le couple de ces articulations serait déterminé par la variable articulaire $q$ et la raideur $k$ du ressort
\item enfin, un robot sans base fixe, donc typiquement le robot humanoïde.
\end{itemize}

Le robot à liaisons flexibles SEA et le robot humanoïde en général sont des systèmes sous-actionnés, \cad qu'ils ont plus de degrés de liberté que d'actionneurs. Regardons de plus prêt le cas du robot humanoïde. On peut modéliser le robot comme un arbre cinématique à base fixe mais avec une liaison flottante \cite[chap.9 p171]{bib_featherstone}, désignée aussi comme \emph{Freeflyer}, à 6 degrés de liberté, et dont le couple "interne" $\tau$ d'actionnement est considéré nul: cette articulation n'est pas actionnée directement. En effet, le robot ne contrôle sa position dans l'espace que via les forces de contact (extérieures) appliquées sous ses semelles. Ces forces sont une contre-réaction de la résultante de l'action de la gravité sur le corps du robot, ajoutée à l'action des articulations du robot.

Si on veut contrôler avec robustesse la trajectoire du \gls{acr_com} du robot (quelque soit la méthode d'asservissement employée), on doit être capable d'estimer avec la plus grande précision possible la position instantanée de celui-ci. Or dans la modélisation énoncée ci-dessus, on connaît les paramètres $q, \dot{q}, \ddot{q}$ de toutes les articulations sauf celle du \emph{Freeflyer}, mais pour cette articulation on connaît le couple moteur appliqué: il est nul. La Dynamique Hybride sauve alors la partie en calculant tous les couples inconnus (ceux des articulations réellement actionnées), et l'accélération du \emph{Freeflyer}. Sa vitesse et position peuvent alors être déduites par intégration.


\section{Contraintes en performances et méthodes d'implémentation} \label{ch_concepts_implEtContr}

\subsection{Contraintes en vitesse d'exécution}

Les algorithmes de Dynamique Directe ou Inverse ont été implémentés en respectant des contraintes strictes en performance, qu'il fallait tenir compte lors de la phase d'optimisation de l'algorithme de Dynamique Hybride. Je me suis alors intéressé aux contraintes mises en évidence dans la description du Filtrage Dynamique Pour La Marche \cite{bib_filtrageTrajectoireCoM}, qui utilise l'algorithme RNEA pour filtrer la trajectoire du centre de masse.

La fréquence d'échantillonnage du robot humanoïde HRP2 s'élève à $200 Hz$ , correspondant à une période de $5 ms$. C'est la fréquence avec laquelle le contrôleur de trajectoire envoie une commande vectorielle de configuration articulaire ($\mathbf{q}$) pour les 30 degrés de liberté du robot. Le filtrage dynamique se fait sur une fenêtre de $1.6 s$ à la même fréquence d'échantillonnage de $200 Hz$, d'après le cahier des charges du \gls{acr_wpg} proposé par Morisawa, ce qui correspond à $200 \times 1.6 = 320$ itérations de calcul d'un vecteur $\mathbf{q}$ \cite[I.B et III.B]{bib_filtrageTrajectoireCoM}, autrement dit à 2 pas de marche. \`{A} chaque période d'échantillonnage, le \gls{acr_wpg} ne dispose que $3 ms$ pour s'exécuter, et cela comprend les 320 itérations de RNEA. Par conséquent ces 320 itérations doivent s'exécuter en moins $400 \mu s$, soit un RNEA en $1.25 \mu s$. comme cette contrainte n'était pas réalisable par les librairies disponibles, la fréquence d'échantillonnage sur la fenêtre de filtrage a été réduite à $20 Hz$, et la cadence des RNEA réduite à 32 toutes les $0.1 s$. Actuellement, les résultats sur HRP2 (Intel(R) Core2(TM) Duo E7500) sont les suivants:
\begin{itemize}
\item[$\centerdot$ vitesse moyenne:] $15 \mu s$
\item[$\centerdot$ vitesse maximale:] $342 \mu s$
\end{itemize}
Et sur un Laptop Intel(R) Core(TM) i7-4700HQ CPU, la vitesse moyenne est d'environ $4.2 \mu s$


\subsection{Contrainte en précision}

Pour la vérification des résultats numériques de l'algorithme à implémenter, les vecteurs de sortie $\ddot{q}$ ou $\tau$ sont comparés à des vecteurs de référence. Ce qui est vérifié est l'écart relatif entre ces grandeurs. L'écart toléré défini pour les algorithmes déjà implémentés est de $10^{-3}$. L'algorithme hybride manipulant les mêmes grandeurs que le RNEA ou CRBA, j'ai supposé cette précision suffisante. Mais idéalement il faudrait faire une étude plus poussée pour vérifier l'impact de cette erreur relative sur la commande du robot, et d'évaluer la marge qu'on a avant que l'impact soit significatif.


\subsection{Algèbre spatiale et méta programmation}

\subsubsection*{L'Algèbre Spatiale et la récursivité}

L'Algèbre Spatiale est à la base des algorithmes de Dynamique décrits par Featherstone. On va rapidement illustrer comment ce formalisme, combiné à la méta programmation, peut nous aider à atteindre le cahier des charges de performance. L'algèbre spatiale est très efficace lorsqu'elle est associée à des algorithmes récursifs, à cause de la composition simplifiée des vecteurs spatiaux de vitesse, accélération et force, et d'autres propriétés particulières comme l'invariance des vecteurs spatiaux par rapport à la base de Plücker choisie (base dans laquelle on exprime le vecteur).

Justement, les algorithmes CRBA et RNEA utilisent beaucoup la récursivité. Ils exploitent également, très efficacement, la sparsité d'un arbre cinématique, en tenant compte de l'absence de couplage entre branches cinématiques (par exemple les bras ou les jambes). Certains langages comme les langages symboliques détectent ces branches et permettent d'éliminer les calcul inutiles qui y sont liés. La Meta-programmation a également cette capacité.

\subsubsection*{La méta programmation et le traitement à la compilation}

La méta programmation signifierait "la programmation d'un programme". C'est en effet un programme qui manipule du code. Le concept est déjà présent dans un compilateur ou un générateur de "parseur" comme YACC. Le mécanisme "template" du C++ fournit méthode native de méta programmation \cite[p2,3]{bib_metaprogramming}. Cette méthode permet de traiter le calcul de grandeur numériques, et de dérouler des séquences de branchement de code à la compilation. La condition dans ces deux cas, est que les grandeurs et branchements sont constants et connus à la compilation.

On peut alors Obtenir une optimisation extrême de certaines fonctions en invoquant la totalité de leur traitement à la compilation. Ceci requiert une architecture et écriture particulière de la fonction: tous ses paramètres et variables locales sont statiques, des types purs (champ de la classe le plus souvent désigné par $::type$) ou des types dit "wrapper type" (champ le plus souvent désigné par $::value$) représentant des valeurs numériques. Dans le premier cas on est en présence d'une \emph{Méta fonction}, dans le deuxième cas en présence d'une \emph{Méta fonction numérique} (\cite[(2.9)]{bib_metaprogramming}. On présente ci-dessous un exemple de méta fonction très connu réalisant la fonction mathématique Factoriel:

\begin{verbatim}
template <int n>
struct factorial {
  enum {
    value = n * factorial<n - 1>::value
  };
};

template <>
struct factorial<0> {   // "specialisation", termine le calcul récursif
  enum{ value = 1 }
};
\end{verbatim} 

Lorsque le compilateur traite l'appel:

\begin{verbatim}
factorial<4>
\end{verbatim}

Il déroule tout le calcul récursif par substitutions consécutive jusqu'à obtenir le résultat $24$.

\textbf{Note:} Certains processeurs tirent également profit de ces méthodes. Ils utilisent ce qu'on appelle la prédiction de branchement, qui consiste à établir des statistiques sur les branchements d'un programme pour les anticiper. La méta programmation soulage ainsi le processeur en réduisant le nombre de branchements qu'il doit traiter.  

\subsection{Le mécanisme de parcours récursif à l'aide du \emph{pattern} "visitor"} \label{ch_concepts_visiteurs}

Le parcours récursif d'arbres cinématiques est récurrent dans les algorithmes de Dynamique, surtout dans le cas su RNEA ou le CRBA. Ce parcours utilise le \emph{pattern} "Visitor" avec deux déclinaisons suivant le sens du parcours de l'arbre:

\begin{itemize}
\item[$\centerdot$] \textsc{DepthFirstTraversal} pour un parcours en profondeur d'abord, implémenté sous \emph{métapod} dans la fonction $\mathit{template<visitor, model, node_{id}> \quad struct \quad depth\_first\_traversal()}$
\item[$\centerdot$] \textsc{BackwardTraversal} pour un parcours arrière en remontant l'arbre vers la racine, implémenté sous \emph{metapo} dans la fonction $\mathit{template<visitor, model, node_{id}, end\_node\_{id}> struct backward\_traversal()}$.
\end{itemize}
\bigskip

\begin{flushleft}
\begin{minipage}[t]{\textwidth}
\setlength{\columnsep}{10pt}
\setlength{\columnseprule}{0.5pt}
\begin{multicols}{2}\raggedcolumns\small
    	\begin{spacing}{1.5}
		\begin{pseudocode}[display]{}{}
		\PROCEDURE{DepthFirstTraversal}{visitor,model,i_{start}}
		    \FOREACH i \in \mu(i_{start}) \DO
		        \CALL{DepthFirstTraversalRec}{visitor,model,i_{start}}
		\ENDPROCEDURE \\
		\PROCEDURE{DepthFirstTraversalRec}{visitor,model,i}
        \CALL{visitor.discover}{model,i} \\
        \FOREACH i \in \mu(i) \DO
            \CALL{DepthFirstTraversal}{visitor,model,i} \\
        \CALL{visitor.finish}{model,i}
		\ENDPROCEDURE
	  \end{pseudocode}
	  \vfill
	  \columnbreak
		\begin{pseudocode}[display]{}{}
		\PROCEDURE{BackwardTraversalPrev}{visitor,model, \vspace{-0.2cm}\\
		                                  i_{start}[,i_{end}]}
		    \textnormal{\# $i_{end}$ est optionnel. Par défaut, $i_{end} \GETS 0$.} \\
		    \CALL{BackwardTraversalPrevRec}{visitor,model, \vspace{-0.2cm}\\
		                                    \lambda(i_{start}),i_{start},i_{end}}
		\ENDPROCEDURE \\
		\PROCEDURE{BackwardTraversalPrevRec}{visitor,model, \vspace{-0.2cm}\\
		                                     i,i_{prev},i_{end}}
		    \textnormal{\# $i=\lambda(i_{prev})$.} \\
        \CALL{visitor.discover}{model,i,i_{prev}} \\
        \IF i \neq i_{end}
        \THEN \CALL{BackwardTraversalPrevRec}{visitor,model, \vspace{-0.2cm}\\
		                                          \lambda(i),i,i_{end}} \\
        \CALL{visitor.finish}{model,i,i_{prev}}
		\ENDPROCEDURE
	  \end{pseudocode}
	  \end{spacing}
\end{multicols}
\end{minipage}
\end{flushleft}

\paragraph{Parcours en profondeur et visiteur:}
La procédure \textsc{DepthFirstTraversal} parcours l'arbre cinématique du \emph{model} en profondeur d'abord, par appels récursifs des noeuds enfants, et en partant du noeud $i_{start}$. Chaque noeud visité, sauf le noeud $i_{start}$, est traité par le "visiteur" défini par deux procédures \textsc{visitor.discover} et \textsc{visitor.finish}. Pour chaque noeud visité $i$, \textsc{Discover} définit le traitement à appliquer avant l'exploration des enfants $\mu(i)$. \textsc{Finish} réalise le traitement dans la phase ascendante, \cad après l'exploration de tous les enfants de $i$.

\paragraph{Parcours en arrière:}
La procédure \textsc{BackwardTraversalPrev} parcours l'arbre en partant du noeud $i_start$, et en remontant vers la racine par l'appel récursif du parent du noeud visité, jusqu'au noeud $end\_node$. Comme pour \textsc{DepthFirstTraversal}, pour chaque noeud visité, sauf pour le noeud $i_start$, les fonctions \textsc{visitor.discover} et \textsc{visitor.finish} sont appelées respectivement avant et après l'exploration du noeud parent.


\subsection{Méta programmation et algorithmes génériques}

Un des désavantages des algorithmes basés sur un modèle générique est qu'ils sont susceptibles de dérouler des calculs inutiles, trop génériques dans le cas de certains modèles spécifiques plus simples, ayant par exemple un nombre réduit de degrés de liberté ou bien que des axes de rotation parallèles. Le C++ templaté et la méta programmation permettent de générer automatiquement des algorithmes spécialisés, dont les traitements ont été réduits au minimum pour réaliser uniquement les calculs nécessaires à un modèle spécifique. La définition et l'application de tels algorithmes suivraient donc le schéma suivant:

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{figs/principeAlgoGenerique.pdf}
\caption{Génération automatique d'algorithmes optimisés et spécialisés}
\end{figure}



\subsection{L'architecture de \emph{metapod}}

\emph{Metapod} fournit une librairie d'algorithmes de calcul dynamique de robot, applicable à un modèle de robot au format \gls{acr_urdf}. Ce format est représenté dans l'outil sous forme de classes templatées. LA librairie est écrite en langage C++ templaté suivant des techniques de méta programmation. Ainsi, chaque algorithme est indépendant des modèles de robot (le modèle est une variable de type et un paramètre d'entrée pour l'algorithme templaté), mais est optimisé et adapté, lors de la compilation, au modèle spécifique traité. La représentation des modèles cinématiques (arbres) et les algorithmes sont basés sur l'algèbre spatiale selon Featherstone, elle même basée sur les concepts de torseurs \cite{bib_featherstone}. On liste ci-dessous les composants principaux de la librairie (sous la racine de \emph{metapod}):
\begin{description}
\item[$\centerdot$ include/metapod:] algorithmes de dynamique de robot et outils
\item[$\centerdot$ data:] fichiers XML donnant la définition URDF des modèles de référence "simple\_arm" (chaîne planaire à 3 corps) et "simple\_humanoid" (modèle humanoïde à 29 corps/articulations et 35 degrés de liberté) pour les tests unitaires et les benchmarks
\item[$\centerdot$ robotbuilder:] librairie d'aide pour la génération du code source 
\item[$\centerdot$ metapodfromurdf:] génère, à l'aide du module "robotbuilder", le code source (fichier d'entête) définissant les classes du modèle de robot, à partir des structures URDF fournies par le parseur URDF
\item[$\centerdot$ build/include/metapod/models:] code source généré par "metapodfromurdf".
\end{description}

Cette architecture a comme dépendance principale le parseur URDF. Celui-ci converti le fichier XML contenant le modèle URDF, en classes C++ envoyées à leur tour au module "metapodfromurdf".

La compilation de metapod se déroule donc en deux étapes: dans un premier temps, le parseur URDF est appelé pour interpréter le fichier XML (\verb;data/<nom_modele>.hh;) et remplir ses classes URDF exportables. Ces données sont ensuite envoyées à "metapodfromurdf" qui génère le code source avec les classes du modèle de robot, encapsulées dans une classe templatée qu'on désigne par \emph{model} (fichier d'entête \emph{metapod} dans \verb;build/include/metapod/models;). En deuxième phase de compilation, les classes du modèle de robot sont compilées avec le code source des algorithmes (\verb;include/metapod;). Les algorithmes sont des structures templates. C'est à ce moment là que celles-ci sont instanciées avec le type [classe \emph{model}].


Il nous reste maintenant à voir un aperçu des concepts et notations en Algèbre Spatiale avant d'aborder l'implémentation de l'algorithme de Dynamique Hybride.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Algèbre spatiale selon Roy Featherstone}
%Formalisme compacte et plus adapté :\vspace{0.3cm}
%- au calcul numérique et récursif\vspace{0.3cm}
%- au parcours en profondeur d'abord d'arbres cinématiques\vspace{0.3cm}

\setmyFiguresFile{figures}

L'algorithme de dynamique hybride a été implémenté suivant le formalisme présenté par Featherstone dans son ouvrage \cite{bib_featherstone} regroupant l'ensemble des algorithmes sur la dynamique des corps rigides: l'algorithme récursif de Newton-Euler (\emph{\gls{acr_rnea}}) ou algorithme de Dynamique Inverse, l'algorithme "corps rigide composite" (\emph{\gls{acr_crba}}) ou algorithme de Dynamique Directe, et l'algorithme de corps articulés (\emph{\gls{acr_aba}}). Ce formalisme est basé sur l'algèbre spatiale, qui définit les grandeurs dynamiques à l'aide d'une notation condensée et efficace, et utilise très souvent des mécanismes récursifs comme le parcours en profondeur de graphes représentant l'arbre cinématique d'un robot. Nous allons présenter dans cette section les fondements de l'algèbre spatiale.\\


\section{Algèbre spatiale: définition des vecteurs spatiaux et d'un modèle de système}

L'algèbre spatiale est un système de notation très concis et léger pour décrire la vitesse, l'accélération et les forces appliquées à des corps rigides, à l'aide de vecteurs à six dimensions (torseurs) dits vecteurs spatiaux. Cette notation réduit grandement la taille des équations de mouvement des modèles cinématique et dynamique du robot. En particulier, elle simplifie la transformation des torseurs entre les repères liés aux différents corps du robot. Quelques exemples seront donnés après la présentation de ces fondements.\\


\subsection{Vecteurs spatiaux: espaces mathématique et bases}

Pour décrire le mouvement d'un corps rigide dans un espace 3D, et ayant six degrés de liberté, nous devons décrire le déplacement en translation et en rotation. Pour cela, on définit des torseurs combinant ces deux types de grandeurs dans des espaces de vecteurs à six dimensions (6D). On définit ainsi :\\
\begin{itemize}
\item dans un espace noté $M^{6}$, un torseur de mouvement pour les vitesses ou accélérations du corps
\item dans l'espace noté $F^{6}$, un torseur de forces pour les forces et les couples appliqués à ce même corps
\end{itemize}
On définit des bases dans ces espaces, ainsi que les opérateurs : somme, produit scalaire, produit vectoriel.\\
Le vecteur de coordonnée $\underline{m}=[m_{1},...,m_{6}]^T$ représente le vecteur $m$ dans la base ${d_{1},...,d_{6}}$ dans $M^{6}$.
De même, $\underline{f}=[f_{1},...,f_{6}]^T$ représente le vecteur $f$ dans la base ${e_{1},...,e_{6}}$ dans $F^{6}$.
Ces bases sont réciproques, normales :

$$
d_{i}\cdot e_{j}=
\begin{cases}
0 \colon i \neq j\\
1 \colon i = j
\end{cases}
$$

Ainsi le produit scalaire entre ces vecteurs s'exprime:

$$
"\cdot" : M^{6} \times D^{6} \mapsto R
\qquad
\qquad
m \cdot f = \underline{m}^T f
$$

\subsection{Vitesse}\label{ch_algSpa_Vitesse}

On veut exprimer la vitesse d'un corps solide dans l'espace $M^{6}$. On considère un corps en rotation autour d'un axe passant par un point $P$ du solide, avec une vitesse angulaire $\omega$, et en translation avec une vitesse linéaire $v_{P}$. On défini un repère $R_{O}$ dans l'espace à trois dimensions du solide ($R(O,x,y,z)$).

\dispTwoFig[H]
{1}{Rotation autour d'un point du solide $P$}
{2}{Rotation autour du centre du repère $O$}
{Vitesse d'un objet en mouvement quelconque (translation et rotation simultanées). Un nouveau point de vue pour le vecteur spatial.}
{fig_VitessePointCoincidant}


Soit $P'$ un point quelconque lié au corps solide $C$ (donc fixe dans n'importe quel repère lié au solide). La vitesse du point $P'$ dans $R$ est donnée par	$v_{P'}=v_{P}+\overrightarrow{P'P} \times w$ .\\
On imagine que le solide s'étend maintenant à tout l'espace autour de lui, englobant ainsi le repère $R$. On peut considérer ainsi un champ de vitesses associé au champ de position de tous les points du solide étendu. Soit le point de ce champ coïncidant avec le centre su repère $O$, autrement dit le point lié au solide (étendu) coïncidant avec $O$ au moment où on mesure la vitesse du solide. Soit $v_{O}$ la vitesse du solide en ce point. Comme pour le point $P'$ évoqué précedemment, on a:
$$
v_{O} = v_{P} + w \times \overrightarrow{PO}\\
\Leftrightarrow v_{P} = v_{O} - w \times \overrightarrow{PO} = v_{O} + w \times \overrightarrow{OP}
$$

On peut donc voir le corps $C$ comme un solide en translation à la vitesse $v_{O}$ et en rotation autour d'un axe passant par $O$ (parallèle à l'axe défini initialement) à la vitesse angulaire $w$. La vitesse de tout point $P$ de ce solide dans le repère $R(O,x,y,z)$ est alors donnée par:
\begin{equation}
v_{P} = v_{O} + \omega \times \overrightarrow{OP}
\quad\quad
\footnote{Bien que la vitesse $v_{P}$ soit définie en fonction de $O$, elle ne dépend pas de l'origine choisie puisqu'il s'agit du vecteur vitesse associé à $P$ par le champ de vitesses du solide, qui lui est indépendant de l'origine. En effet, $v_{O}$ et $\overrightarrow{OP}$ dépendent tous deux de $O$, mais ces dépendances se compensent.}
\end{equation}
\noindent
Les vecteurs spatiaux sont équivalents à des torseurs, pour lesquels on retrouve les même représentations de champs de position et champs de vitesse (annexe \ref{appx_torseursToalgSpa_torseurs_appl}).\\

On veut exprimer les coordonnées de $w$ et $v_{O}$ dans le repère cartésien $R(O,x,y,z)$. Pour cela, on définit la base orthonormée de \emph{Plücker} dans l'espace des torseurs de mouvement $M^{6}$:\\

\begin{figure}[H]
\minipages[3]{t}{.3}{.3}{.4}
{%
  \dispFig[H]{3}{4cm}{}{}
}{%
  \begin{align*}
  D_{O} = \lbrace &\textbf{d}_{Ox}, \textbf{d}_{Oy}, \textbf{d}_{Oy}, \\
  &\textbf{d}_{x}, \textbf{d}_{y}, \textbf{d}_{z} \rbrace \subset M^{6}
  \end{align*}
}{%
  \begin{tabbing}
  \= $\textbf{d}_{Ox}$ \= vecteur unitaire de rotation autour de $O_{x}$\\
  \> $\textbf{d}_{Oy}$ \> vecteur unitaire de rotation autour de $O_{y}$\\
  \> $\textbf{d}_{Oz}$ \> vecteur unitaire de rotation autour de $O_{z}$\\
  \> $\textbf{d}_{x}$  \> vecteur unitaire de translation le long de $O_{x}$\\
  \> $\textbf{d}_{y}$  \> vecteur unitaire de translation le long de $O_{y}$\\
  \> $\textbf{d}_{z}$  \> vecteur unitaire de translation le long de $O_{z}$\\
  \end{tabbing}
}
\caption{Base de \emph{Plücker} dans $M^{6}$}
\label{fig_basePlucker}
\end{figure}

Voici les coordonnées cartésiennes de $w$ et $v_{O}$, ainsi que leur concaténation constituant les coordonnées du vecteur spatial $\widehat{v}$ dans la base de \emph{Plücker}:\\

\begin{minipage}[c]{.55\textwidth}
$$
\underline{w}=
\begin{bmatrix}
w_{x} \\
w_{y} \\
w_{z}
\end{bmatrix}
\quad \texttt{et} \quad
\underline{v}_{O}=
\begin{bmatrix}
v_{Ox} \\
v_{Oy} \\
v_{Oz}
\end{bmatrix}
\quad \Rightarrow \quad
\underline{\widehat{v}}_{O}=
\begin{bmatrix}
\underline{w} \\
\underline{v}_{O}
\end{bmatrix}
=
\begin{bmatrix}
w_{x} \\
w_{y} \\
w_{z} \\
v_{Ox} \\
v_{Oy} \\
v_{Oz}
\end{bmatrix}
$$
\end{minipage}
\begin{minipage}[c]{.45\textwidth}
\begin{align*}
\quad \texttt{représentant} \quad
\widehat{v} = 
  &w_{x}\textbf{d}_{Ox} + w_{y}\textbf{d}_{Oy} + w_{z}\textbf{d}_{Oz} \\
  &+ v_{Ox}\textbf{d}_{x} + v_{Oy}\textbf{d}_{y} + v_{Oz}\textbf{d}_{z}
\end{align*}
\end{minipage}

\vspace{0.3cm} % retour à la ligne

Le vecteur spatial $\widehat{v}$ rassemble les six composantes représentant complètement les mouvements $\underline{w}$ et $\underline{v}_{O}$ du corps $C$. Ce vecteur a une propriété majeure qui est l'invariance par rapport à la base de \emph{Plücker} choisie (annexe \ref{appx_dem}). La propriété d'invariance se vérifie pour tout point $O$ et $P$ fixes dans l'espace et une orientation quelconque des repères $R(O,x,y,z)$ et $R'(P,x,y,z)$. Nous pouvons trouver la démonstration complète de cette propriété d'invariance dans l'annexe \ref{appx_dem}.


\subsection{Force}

Nous nous intéressons à présent aux forces appliquées au corps rigide $\emph{C}$. Soit une force $\textbf{f}$ quelconque appliquée au solide. On le définit comme une somme:
\begin{itemize}
\item d'une force linéaire passant par un point donné $P$ de $\emph{C}$
\item d'un couple $\textbf{n}_{P}$ autour d'un axe passant par $P$
\end{itemize}

Comme précédemment, on retrouve l'équivalence avec un torseur force, où la force linéaire ici est le vecteur $\mathbf{S}$ du torseur, et le couple est le moment $\mathbf{M(O)}$ du torseur (annexe \ref{appx_torseursToalgSpa_torseurs_appl}).


\subsection{Articulations, contraintes et transformation de bases} \label{ch_algSpa_transformations}

Dans cette section, nous allons juste aborder les notation importantes utilisées dans les algorithmes de Dynamique, et décrivant les articulations entre les corps, les repères liés au corps, les transformations associées à ces articulations et entre les différents repères. On illustre l'ensemble de ces entités dans la figure \ref{fig_corpsEtReperes}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{figs/modeleGeoEtArticulations.png}
  \caption{Modèle géométrique d'un système de corps rigides, et ses repères liés. extrait de la \cite[section 4.2, figure 4.7]{bib_featherstone}}
  \label{fig_corpsEtReperes}
\end{figure}

Pour pouvoir déterminer les contraintes d'une articulation, il faut connaître les mouvements autorisés par l'articulation (modèle de l'articulation) et sa position relative par rapport à chacun des corps qu'elle connecte (géométrie du système). Comme illustré dans la figure, on peut décrire la position du corps $B_1$ par rapport à $B_0$ comme la position du repère $F_1$ par rapport à $F_0$. ça nous donne la transformation $^iX_0$ exprimant les vecteurs spatiaux du repère $F_0$ dans le repère $F_1$.

On défini par $^{i,j}X_i$ la transformation correspondant à la position du repère $F_{i,j}$ par rapport au repère $F_i$. $F_i$ est le repère lié à la base du corps $i$ (peut être confondu avec le centre d'inertie). $F_{i,j}$ est le repère lié à l'articulation connectant le corps $i$ et le corps $j$. Featherstone emploie le plus souvent une notation plus simple:

\begin{equation*}
^jX_i = ^jX_{i,j} \cdot ^{i,j}X_i = X_J \cdot X_T
\end{equation*}

où $X_T$ est la position de l'articulation $j$ par rapport au corps $i$, et $X_J$ est la transformation résultant de l'actionnement de l'articulation (rotation, translation, ...).



\subsubsection*{Composition de vitesses}
On définit la matrice de sélection $S_k$ d'une articulation $k$ donnée, liant la vitesse spatiale du corps $k$ à la variable articulaire $\dot{q}_k$ (\cite[section 3.5]{bib_featherstone}). Soit $v_J$ la "vitesse à travers l'articulation $i$", \cad la vitesse du corps $k$ par rapport au corp parent $\lambda(k)$, et soit $\dot{q}_i$ la variable vitesse articulaire associée. On a alors:
\begin{align}
\textnormal{Vitesse du corps $k$ par rapport à $\lambda(k)$ dans le repère $R_k$ lié au corps $k$} : {^kv_J} &= {^kS_k} \: \dot{q}_k \\
\textnormal{Vitesse du corps $k$ par rapport à $\lambda(k)$ dans le repère base $R_0$ lié au corps $0$} : {^0v_J} &= {^0X_k} {^kS_k} \: \dot{q}_k = {^0S_k} \: \dot{q}_k \\
\textnormal{Vitesse du corps $k$ par rapport à $0$ dans le repère $R_0$} : {^0v_k} &= {^0v_{\lambda(k)}} + {^0v_{J}} \\
&= {^0v_{\lambda(k)}} + {^0S_k} \: \dot{q}_k \\
\textnormal{Par récursivité} : v_k &= \sum_{i \in \kappa(k)} {^0S_i} \: \dot{q}_i
\end{align}
Ceci exprime la composition des vitesses des corps supportant le corps $k$.

\paragraph*{Différence entre la notion de vitesse relative à un corps et vitesse exprimée dans le repère dans le repère de \emph{Plücker} de ce même corps:} La différence entre $v_{i:j} = {^0v_{i:j}}$ (vitesse du corps $i$ par rapport à $j$ exprimée en un repère fixe quelconque $R_0$), et $^iv_j = {^iv_{0:j}}$ (vitesse du corps $j$ par rapport à un repère fixe quelconque $R_0$, exprimée dans le repère lié à $i$).
En algèbre spatiale, lorsqu'on note une vitesse spatiale ${^iv_{0:j}}$ exprimée dans le repère lié à un corps $i$ donné, on considère une "photo" instantanée de ce repère, on le considère donc fixe. La composition (somme) des vitesses des différents corps se fait à travers la somme des vecteurs spatiaux, et non pas à travers les matrices de passage $^BX_A$ entre repères de \emph{Plücker}. C'est à dire que si un corps $j$ est immobile par rapport à un autre corps $j$, mais tous les deux sont mobiles par rapport à un repère fixe $R_0$, on a ${^iv_j } = {^iv_{0:j}} \neq 0$.




\chapter{Implémentation d'un algorithme dynamique hybride pour la prise en compte des liaisons flexibles} \label{ch_impl}

\setmyFiguresFile{hybridDynamics4etapes}

Dans les sections précédentes, nous avons posé les bases de l'algèbre spatiale des torseurs cinématiques et dynamiques, ainsi que la modélisation généralisée d'un arbre cinématique (\emph{modèle de sytème} du robot). Nous allons décrire dans cette section la définition de l'\emph{algorithme hybride}, et son implémentation qui s'est déroulée sur plusieurs phases:\\

\begin{itemize}
\item (section \ref{ch_impl_apercu}) Analyse de l'algorithme tel qu'il est présenté par Featherstone (\cite{bib_featherstone} chap.9).
\item (sections \ref{ch_impl_equReord} à \ref{ch_impl_calculTau2})
  \begin{itemize}
  \item[$\centerdot$] Analyse des dépendances:
  \begin{itemize}
    \item[-] méthodes (\gls{gls_jcalc}, méthodes de résolution des systèmes linéaires)
    \item[-] impacts sur la définition du modèle du système dynamique (modèle \gls{acr_urdf}) et sur le parseur de modèle URDF pour la prise en compte des spécificités de l'algorithme hybride
    \item[-] Identification et analyse des algorithmes réutilisés par l'algorithme de Dynamique Hybride, qui étaient déjà implémentés (\gls{acr_rnea} et \gls{acr_crba}), mais doivent éventuellement être modifiés voire ré-implémentés entièrement
  \end{itemize}
  \item[$\centerdot$] Identification et prise en main des outils logiciels pour la manipulation de matrices et systèmes linéaires (matrices et solveurs \gls{gls_eigen} \cite{bib_eigen_tutorial_alg_lin})
  \item[$\centerdot$] Implémentation d'une version modifiée des algorithmes \gls{acr_rnea} et \gls{acr_crba} adaptée à l'\emph{hybrid dynamics}, ainsi que de l'algorithme principal dans \emph{metapod}. Lors de cette phase, j'ai dû apporter certains compléments au calcul des éléments de la matrice d'inertie, face à la proposition initiale de Featherstone non totalement explicitée, afin de permettre le calcul de toutes les inconnues.
  \end{itemize}
\item ( section \ref{ch_impl_optimisation}) Optimisation logique visant à réduire le nombre d'étapes de calcul, ainsi que l'optimisation de la compilation et exécution de ces étapes à l'aide des thecniques de \emph{méta programmation}
\end{itemize}


\section{l'algorithme hybride en quatre étapes}

\subsection{Aperçu de l'algorithme} \label{ch_impl_apercu}

L'algorithme Dynamique Hybride est une généralisation de la dynamique directe et de la dynamique indirecte (\gls{acr_rnea}). En effet, il applique la dynamique directe aux articulations dont on connaît les couples ou forces appliquées, et la dynamique inverse aux articulations dont on connaît les accélérations. Toutes les inconnues sont ainsi résolues.\\
Cet algorithme est décomposé en cinq étapes incluant le déroulement complet d'un \gls{acr_rnea}, ainsi que d'un \gls{acr_crba} pour la construction de la matrice d'inertie du système entier. Ces deux algorithmes sont utilisés sous une forme adaptée à l'algorithme hybride, et j'ai dû apporter certains compléments afin de permettre leur intégration dans l'algorithme principal.\\

Nous considérons l'équation de mouvement relative à un arbre cinématique générique (à base fixe ou flottante), sous la forme matricielle (\cite{bib_featherstone} chap.6) comme suit:

\begin{equation} \label{equ_equationMvt}
H(q)\ddot{q} + C(q,\dot{q},f^{ext}) = \tau
\end{equation}

\medskip

\begin{wrapfigure}{r}{0.5\textwidth}
  \begin{flushright}
  \begin{minipage}[t]{0.45\textwidth}
  \begin{description}
    \item[$q, \dot{q}, \ddot{q}$ :] vecteurs de position, vitesse, accélération
    \item[$\tau$ :] forces/couples moteurs (internes)
    \item[$H$ :] matrice des termes inertiels
    \item[$C$ :] forces de précontrainte extérieures
  \end{description}
  \end{minipage}
  \end{flushright}
\end{wrapfigure}

qui regroupe les éléments dynamiques décrits ci-contre: vecteurs de position / vitesse / accélération des articulations; les couples moteurs (internes) appliqués aux articulations; les forces extérieures au système éventuelles appliquées aux corps et ramenés aux articulations; la matrice inertielle dans l'espace de configuration et le vecteur de forces de précontrainte ou "bias" (force de Coriolis, la pesanteur, etc).
Pour simplifier les notations, les dépendances $q$, $\dot{q}$ et $f^x$ des coefficients $H$ et $C$ de l'équation seront omises. Les variables sont les forces/couples $\tau$ et les accélérations $\ddot{q}$.\\
Pour chaque articulation $i$, on connaît soit le couple appliqué soit l'accélération. L'objectif est de calculer toutes les variables inconnues. Cela passe par une mise en forme de l'équation de mouvement, visant à ramener toutes les variables inconnues du même côté de l'égalité, et laisser toutes les variables connues de l'autre côté. On obtient ainsi l'équation réordonnée:

\begin{align}
&\begin{bmatrix}
  H_{11} & 0 \\
  H_{21} &  -I
\end{bmatrix} 
\cdot
\begin{bmatrix}
  \ddot{q}_1 \\
  \tau_2
\end{bmatrix} 
=
\begin{bmatrix}
  \tau_1 \\
  0
\end{bmatrix} 
-
\begin{bmatrix}
  C'_{1} \\
  C'_{2}
\end{bmatrix} \label{equ_equationMvt_dynHyb2} \\
\notag \\
&\textnormal{Avec} \qquad
\begin{bmatrix}
  C'_{1} \\
  C'_{2}
\end{bmatrix}
=
\begin{bmatrix}
  C_{1} \\
  C_{2}
\end{bmatrix}
+
\begin{bmatrix}
  H_{12} \ddot{q}_2 \\
  H_{22} \ddot{q}_2
\end{bmatrix} \label{equ_cPrime}
\end{align}

\`{à} partir de là, la résolution de l'équation de mouvement de la dynamique hybride se fera en quatre étapes, suivant la description par Featherstone \cite[section 9.1 p173]{bib_featherstone}:
\begin{enumerate}
\item calculer $C'$ d'après l'équation \eqref{equ_equationMvt_dynHyb2}
\item calculer $H_{11}$
\item résoudre $H_{11} \ddot{q}_1 = \tau_1 - C'_1$
\item calculer $\tau_2$ d'après l'équation \eqref{equ_equationMvt_dynHyb2}
\end{enumerate}

\noindent
On détaille par la suite la mise en forme de l'équation \eqref{equ_equationMvt_dynHyb2} et les 4 étapes énoncées.


\subsection{Séparation des variable connues/inconnues et mise en place de l'équation de mouvement réordonnée} \label{ch_impl_equReord}

\subsubsection{Permutation des vecteurs de variables et de coefficients}

\begin{wrapfigure}{r}{0.5\textwidth}
  \begin{center}
    \incFig[1]{.3\textwidth}
    \caption{Graphe de l'arbre cinétique}
    \label{fig_chdaArbreK1}
  \end{center}
\end{wrapfigure}

Soit le sous-ensemble d'articulations pour lesquelles on connaît le couple $\tau$ de forces appliquées. On désigne cet ensemble celui des articulations en mode "forward-dynamics" ou "articulations \emph{fd}" ou encore \emph{fd}. L'ensemble complémentaire regroupe les "articulations en mode "inverse-dynamics" ou "id". l'ensemble \emph{fd} est supposé connu et fournit par le modèle du système. Nous noterons $n_{\emph{fd}}=\vert fd \vert$, $n_{\emph{id}}=\vert id \vert$ et $n_{dof}=n_{\emph{fd}}+n_{\emph{id}}=\vert \ddot{q} \vert$. Il s'agit là d'un impact, qu'on détaille en fin de section, sur la définition du modèle standard \gls{acr_urdf} et du "parseur" respectif, tous deux définis à la base dans le standard \gls{acr_ros}.\\
Avant de pouvoir déplacer toutes les variables inconnues du même côté de l'égalité, nous devons les regrouper. Pour cela, nous appliquons une permutation à tous les éléments de l'équation de mouvement. Commençons par les vecteurs de variables et de coefficients. Nous définissons ainsi la matrice de permutation $\mathbf{Q}$ qui réordonne les vecteurs $q$, $\dot{q}$, $\ddot{q}$ en plaçant les variables inconnues en premier. Considérons l'exemple simple ci-contre. Comme vu dans l'établissement de l'équation de mouvement au chapitre \ref{ch_algSpa_equationMouvement}, l'ordre des variables $q_i$, $\dot{q}_i$, $\ddot{q}_i$, dans les vecteurs respectifs, est donné suivant le parcours de l'arbre cinétique en profondeur d'abord:

\begin{Parallel}[v]{.4\textwidth}{.5\textwidth}
\ParallelLText{%
\begin{align*}
\ddot{q} &= 
\begin{bmatrix}
  \ddot{q}_1 & \ddot{q}_2 & \textcolor{blue}{\ddot{q}_4} & \ddot{q}_5 & \textcolor{blue}{\ddot{q}_3} & \ddot{q}_6 & \ddot{q}_7
\end{bmatrix}^T \\
\medskip
Q &= 
\begin{bmatrix}
  0 & 0 & 1 & 0 & 0 & 0 & 0 \\
  0 & 0 & 0 & 0 & 1 & 0 & 0 \\
  1 & 0 & 0 & 0 & 0 & 0 & 0 \\
  0 & 1 & 0 & 0 & 0 & 0 & 0 \\
  0 & 0 & 0 & 1 & 0 & 0 & 0 \\
  0 & 0 & 0 & 0 & 0 & 1 & 0 \\
  0 & 0 & 0 & 0 & 0 & 0 & 1  
\end{bmatrix}
\end{align*}
}
\ParallelRText{%
\begin{align*}
n_{dof}&=7, n_{\emph{fd}}=2, n_{\emph{id}}=5 \\
Q \ddot{q} &= 
\begin{bmatrix}
  \textcolor{blue}{\ddot{q}_4} & \textcolor{blue}{\ddot{q}_3} & \ddot{q}_1 & \ddot{q}_2 & \ddot{q}_5 & \ddot{q}_6 & \ddot{q}_7
\end{bmatrix}
=
\begin{bmatrix}
  \underline{\ddot{q}_1} \\
  \underline{\ddot{q}_2}
\end{bmatrix} \\
\textnormal{ et de même } \\
Q \tau &= 
\begin{bmatrix}
  \underline{\tau_1} \\
  \underline{\tau_2}
\end{bmatrix}
\qquad \textnormal{et} \qquad
Q C = 
\begin{bmatrix}
  C_1 \\
  C_2
\end{bmatrix}
\end{align*}
}
\end{Parallel}
\medskip
Avec $\underline{\ddot{q}_1}$ et $\underline{\tau_1}$ les sous-vecteurs des variables (\emph{fd}), de dimensions $(n_{\emph{fd}} \times 1)$, et $\underline{\ddot{q}_2}$ et $\underline{\tau_2}$ les sous-vecteurs des variables (\emph{id}), de dimensions $(n_{\emph{id}} \times 1)$. Pour alléger la notation, on notera ces vecteurs tout simplement $\ddot{q}_1$, $\ddot{q}_2$, $\tau_1$ et $\tau_2$.

\subsubsection{Quelques propriétés de $Q$}

\begin{flushleft}
\begin{itemize}
\item[$\centerdot$] Il y a un seul élément à 1 par ligne et un seul élément à 1 par colonne, tous les autres éléments étant à 0
\item[$\centerdot$] D'après la forme de $Q$, on montre facilement que pour toute matrice carrée $m$, le produit à gauche $m'=Qm$ permute les lignes de $m$, et le produit à droite $m'=mQ$ permute les colonnes. En effet, dans le produit $m'=Qm$, chaque élément $Q_{ij}$ à 1 affecte la ligne $j$ de $m$ à la ligne $i$ de $m'$. Pour la permutation de colonnes, il suffit de passer par la transposée de $m$. Soit $Q'$ la transformation permutant les colonnes:

\begin{center}
\(
\begin{aligned}
&Q : m \mapsto Q m \qquad \textnormal{est une permutation de lignes.} \\
&\textnormal{... on transpose les matrices en relation. Les lignes deviennent des colonnes,} \\
&\textnormal{qui héritent donc du même ordonnancement ...} \\
&Q': m^T \mapsto (Q m)^T = m^T Q^T \quad \implies Q'=Q^T \\
&Q^T: m \mapsto m Q^T \qquad \textnormal{est donc une permutation de colonnes.} \\
\end{aligned}
\)
\end{center}
\medskip
\item[$\centerdot$] Toute matrice de permutation est inversible et $Q^{-1}=Q^T$. Cette propriété se démontre simplement grâce aux propriétés de la transposition de matrice. Soit une matrice quelconque $A$. $(AA^T)^T=(A^T)^TA^T=AA^T$, donc la matrice $AA^T$ est une matrice symétrique. On en déduit que $QQ^T$ est une matrice symétrique. Or $Q^T$, ainsi que $Q(Q^T)$ (permutation des lignes de $Q^T$), ont les mêmes propriétés que $Q$ (un seul élément à 1 par ligne). On en déduit que $QQ^T$ est une matrice symétrique avec un seul élément à 1 par ligne, ce qui correspond à la matrice identité $I$.
\end{itemize}
\end{flushleft}

%Ces propriétés sont décrites plus en détail en annexe \ref{appx_algLineaire}.

\subsubsection{permutation de la matrice d'inertie et reformulation de l'équation de mouvement}

On applique la permutation $Q$ à tous les éléments de l'équation de mouvement \eqref{equ_equationMvt}:
\begin{spacing}{1.5}
\begin{align}
&H \ddot{q} + C = \tau \notag \\
\iff &H \ddot{q} = \tau - C \notag \\
\iff &Q H \ddot{q} = Q \tau - Q C \label{equ_local_eqMvt_1} \\
\textnormal{or} \qquad &Q^T Q = I \iff \ddot{q} = Q^T Q \ddot{q} \qquad \textnormal{donc} \notag \\
\eqref{equ_local_eqMvt_1} \iff &(Q H Q^T) (Q \ddot{q}) = Q \tau - Q C \notag \\
\iff 
&\begin{bmatrix}
  H_{11} & H_{12} \\
  H_{21} & H_{22}
\end{bmatrix} 
\cdot
\begin{bmatrix}
  \ddot{q}_{1} \\
  \ddot{q}_{2}
\end{bmatrix} 
= 
\begin{bmatrix}
  \tau_{1} \\
  \tau_{2}
\end{bmatrix} 
-
\begin{bmatrix}
  C_{1} \\
  C_{2}
\end{bmatrix} \label{equ_local_eqMvt_2}
\end{align}
\end{spacing}

où $H_{11}$ est de dimensions ($n_{fd} \times n_{fd}$), $H_{12}$ de dimensions ($n_{fd} \times n_{id}$), $H_{21}$ est de dimensions ($n_{id} \times n_{fd}$) et $H_{22}$ de dimensions ($n_{id} \times n_{id}$).
\subsubsection{regroupement des inconnues à gauche de l'équation}

Il ne reste plus qu'à regrouper $\ddot{q}_1$ et $\tau_2$ à gauche de l'équation:

\begin{alignat}{2}
\eqref{equ_local_eqMvt_2} \iff
&\begin{bmatrix}
  H_{11} \\
  H_{21}
\end{bmatrix} 
\cdot \ddot{q}_1
+
\begin{bmatrix}
  H_{12} \\
  H_{22}
\end{bmatrix}
\cdot \ddot{q}_2
&&=
\begin{bmatrix}
  \tau_1 \\
  0
\end{bmatrix} 
+
\begin{bmatrix}
  0 \\
  I
\end{bmatrix} 
\cdot \tau_2
-
\begin{bmatrix}
  C_{1} \\
  C_{2}
\end{bmatrix} \notag \\
\notag \\
\iff
&\begin{bmatrix}
  H_{11} \\
  H_{21}
\end{bmatrix} 
\cdot \ddot{q}_1
+
\begin{bmatrix}
  0 \\
  -I
\end{bmatrix} 
\cdot \tau_2
&&=
\begin{bmatrix}
  \tau_1 \\
  0
\end{bmatrix} 
-
\begin{bmatrix}
  H_{12} \\
  H_{22}
\end{bmatrix}
\cdot \ddot{q}_2
-
\begin{bmatrix}
  C_{1} \\
  C_{2}
\end{bmatrix} \label{equ_equationMvt_dynHyb1} \\
\notag \\
\iff
&\begin{bmatrix}
  H_{11} & 0 \\
  H_{21} &  -I
\end{bmatrix} 
\cdot
\begin{bmatrix}
  \ddot{q}_1 \\
  \tau_2
\end{bmatrix} 
&&=
\begin{bmatrix}
  \tau_1 \\
  0
\end{bmatrix} 
-
\begin{bmatrix}
  C'_{1} \\
  C'_{2}
\end{bmatrix}
\end{alignat}
\begin{align}
&\textnormal{Avec} \qquad
\begin{bmatrix}
  C'_{1} \\
  C'_{2}
\end{bmatrix}
=
\begin{bmatrix}
  C_{1} \\
  C_{2}
\end{bmatrix}
+
\begin{bmatrix}
  H_{12} \ddot{q}_2 \\
  H_{22} \ddot{q}_2
\end{bmatrix}
\end{align}
\\
Nous avons ainsi obtenu l'équation de mouvement pour la dynamique hybride.

\subsubsection{implémentation} \label{ch_implURDF}

\paragraph{Modifications à apporter au modèle URDF (format XML) et au parseur URDF:}

Afin de réaliser les permutations décrites ci-dessus, nous devons dans un premier temps ajouter la génération de la classification $fd$/$id$ des articulations dans le fichier de modèle généré par "metapodfromurdf":

\noindent
\verb;../metapod/build/include/models/<nom_modele>/<nom_modele>.hh; (voir section \ref{ch_concepts_implEtContr}). Plus précisément, nous voulons faire apparaître dans chaque classe "Node" attribuée à un noeud, un champ statique et constant\footnotemark[1] (booléen) représentant l'attribut \verb;fwdDyn; ("Forward Dynamics") associé à l'articulation qui supporte le corps de classe "Node":
\begin{equation*}
fwdDyn = 
\begin{cases}
  \verb;false; & \textnormal{l'articulation $\in id \quad$ (on connaît son accélération)} \\
  \verb;true; & \textnormal{l'articulation $\in fd \quad$ (on connaît son couple)}
\end{cases}
\end{equation*}

\footnotetext[1]{Le caractère statique et constant de \verb;fwdDyn; est indispensable à certaines optimisations de méta programmation.}

Nous avons vu, dans la section \ref{ch_concepts_implEtContr}, l'architecture globale de \emph{metapod}. La création d'un champ dans la classe du modèle interne à \emph{metapod} et dans le fichier URDF XML impacte toute la chaîne de conversion entre ces deux points:
\begin{description}
\item[$\centerdot$ fichier XML URDF:] définition dans le fichier XML URDF, d'un attribut \verb;fwd_dyn; binaire désignant le type d'articulation, aligné avec la définition de \verb;fwdDyn; plus haut. Au moment de choisir un emplacement pour ce nouvel attribut, nous avons considéré l'application au traitement des articulations flexibles. Il s'agit de définir un champ à intégrer dans le standard URDF de ROS. Le choix doit être pertinent et justifiable pour pouvoir être approuvé par le(s) modérateur ou responsable du composant. Pour ces raisons, nous avons choisi de lier \verb;fwdDyn; à la spécification XML $\mathbf{model}  \longrightarrow \mathbf{joint}  \longrightarrow \mathbf{dynamics}$, qui décrit déjà les propriétés physiques de l'articulation: viscosité (\verb;damping;) et frottements (\verb;friction;). Notre proposition finale, une fois l'algorithme hybride validé, \emph{metapod}, pourrait être la création d'un champ raideur (\verb;stiffness;) du ressort. Un coefficient de raideur pourrait être utilisé dans des développements futurs, mais dans un premier temps, servirait à classer l'articulation: une raideur non nulle serait interprêtée comme \verb;fwdDyn=1;.
\item[$\centerdot$ Parseur URDF:] conversion de ce nouvel attribut, du fichier URDF vers les structures URDF du parseur (composants \verb;/urdfdom et /urdfdom_headers; du parseur URDF)
\item[$\centerdot$ metapodfromurdf:] Génération du nouveau champ dans le fichier d'entête $<nom\_modèle>.hh$ dans \emph{metapod}
\item[$\centerdot$ Rétro-compatibilité:] création d'un drapeau de compilation pour assurer la rétro-compatibilité de \emph{metapod} pour dé-corréler l'intégration de \emph{metapod} et du parseur URDF dans leurs bases officielles respectives. Ce drapeau peut prendre trois valeurs possibles: \verb;ALL_ON; $\longrightarrow$ toutes les articulations $\in fd$; \verb;ALL_OFF; $\longrightarrow$ toutes les articulations $\in id$; \verb;FROM_URDF; $\longrightarrow$ les articulations sont classées en fonction du champ \verb;fwd_dyn; du modèle URDF XML. Les deux premières configurations permettent d'intégrer le développement de l'hybride dynamique dans la base officielle de \emph{metapod} sans les dépendances du parseur URDF.
\end{description}
\bigskip

\paragraph{méthodes matricielles de permutation de vecteurs et matrices}
La permutation des vecteurs se fait à l'aide d'une classe de la librairie \emph{Eigen} dédiée à ce type d'opération, la classe: \verb;Eigen::PermutationMatrix;. Un objet de cette classe peut être utilisé sous forme de matrice orthogonale: \verb;Eigen::PermutationMatrix::toDenseMatrix(); ; mais aussi sous la forme d'une base de permutation. Dans le premier cas, le produit d'un objet $Q$ de cette classe par une matrice $A$ carrée est un vrai produit matriciel, qui a une complexité de calcul $O(n^3)$ (où $n$ est la taille de la matrice). Dans le deuxième cas, le produit est surchargé par une méthode de permutation de lignes ou de colonnes, de complexité $O(n)$. Il est donc impératif, pour toutes nos permutations, d'utiliser la deuxième forme (instance directe de la classe \verb;Eigen::PermutationMatrix;). On désignera l'objet de cette classe par "opérateur de permutation".

Nous avons mesuré une différence de performance entre les deux méthodes, dans une configuration i7 quadcore, s'élevant à $20\mu s$ pour le produit $Q H Q^T$, sur un temps total d'exécution de l'hybride dynamics d'environ $36\mu s$, ce qui est considérable.

La construction de l'opérateur de permutation pouvait se faire pendant l'une des phases suivantes:
\begin{itemize}
  \item la génération par le module \emph{metapodfromurdf} du modèle du robot (fichier .hh)
  \item la phase de compilation du modèle dans \emph{metapod}
  \item l'exécution de l'algorithme de dynamique hybride
\end{itemize}
l'opérateur de permutation se crée à partir d'un vecteur de permutation (classe \verb;Matrix; de Eigen) qu'on rempli suivant les permutations désirées. Le soin nous est réservé de vérifier que ces permutations équivalent à une matrice de permutation $Q$ orthogonale. Nous avons choisi d'éviter d'introduire dans le module \emph{metapodfromurdf} des dépendances avec les algorithmes de \emph{metapod}. De plus, remplir ces vecteurs en parcourant l'arbre cinématique en phase de compilation est assez complexe, faisant appel à des "metafonctions". On peut se permettre de faire le remplissage en phase d'exécution de \emph{metapod} puisque l'opérateur de permutation est calculé une bonne fois pour toutes. On choisit de le faire dans le constructeur de l'objet de la classe du modèle (classe \verb;<nom_modele>;), donc avant tout appel possible de la méthode de dynamique hybride \verb;chda();.

\paragraph{résolution du système...}
Déroulons maintenant les quatre étapes de l'algorithme, énoncées plus haut: calcul de $C'$, calcul de $H_{11}$, résolution de $H_{11} \ddot{q}_1 = \tau_1 - C'_1$ et calcul de $\tau_2$.


\subsection{calcul de C'}

$C'$ est l'ensemble des forces et couples de forces motrices $\tau$ assurant une accélération nulle pour les articulations \emph{fd} ($\ddot{q}_1=0$) et l'accélération donnée $\ddot{q}_2$ pour les articulations \emph{id}. en effet on obtient:

\begin{equation}
\textnormal{Pour} \quad \ddot{q}=
\begin{bmatrix}
  0 \\
  \ddot{q}_2
\end{bmatrix}
: \quad
\eqref{equ_equationMvt_dynHyb2} \iff
\begin{bmatrix}
  0 \\
  -I
\end{bmatrix} 
\cdot \tau_2
=
\begin{bmatrix}
  \tau_1 \\
  0
\end{bmatrix} 
-
\begin{bmatrix}
  C'_1 \\
  C'_2
\end{bmatrix}
\iff
\begin{bmatrix}
  C'_1 \\
  C'_2
\end{bmatrix}
=
\begin{bmatrix}
  \tau_1 \\
  \tau_2
\end{bmatrix} 
\end{equation}
\medskip
Les composantes $C'_1$ et $C'_2$ s'obtiennent donc en calculant les couples moteurs $\tau_1$ et $\tau_2$\footnotemark[2]grâce à la fonction de dynamique inverse (\gls{gls_rnea}) suivante:

\begin{equation}
C'=ID \left( q,\dot{q},Q^T
\begin{bmatrix}
  0 \\
  \ddot{q}_2
\end{bmatrix} \right)
\end{equation}

\footnotetext[2]
{Dans l'équation \eqref{equ_equationMvt_dynHyb1}, les matrices ou vecteurs $H_{11}$, $H_{21}$, $H_{22}$, $C_1$ et $C_2$ sont constants par rapport aux variables $\ddot{q}$ et $\tau$. Sous l'hypothèse \(\ddot{q}=\begin{bmatrix} 0 & \ddot{q}_2\end{bmatrix}^T\), la valeur de $C'$ est directement fixée par la relation \eqref{equ_cPrime}, et reste valable pour la suite de la résolution du problème. Par contre, $\tau_1$ et $\tau_2$ sont des variables déterminées par la fonction $ID$, et valables uniquement sous l'hypothèse \(\ddot{q}=\begin{bmatrix} 0 & \ddot{q}_2\end{bmatrix}^T\). Leurs valeurs intermédiaires servent uniquement à calculer $C'$.}

Parmi les paramètres classiques de la fonction $ID$, nous avons remplacé $\ddot{q}$ par 
\(Q^T \begin{bmatrix} 0 & \ddot{q}_2 \end{bmatrix}^T\), 
ce qui correspond à mettre à 0, dans le vecteur original $\ddot{q}$, toutes les variables qui étaient regroupées dans le vecteur réordonné $\ddot{q}_1$.\\


\subsubsection{implémentation}

Nous pouvons visualiser ci-dessous les opérations exécutées sur le vecteur d'entrée $\ddot{q}$ pour obtenir la forme désirée \(Q^T \begin{bmatrix} 0 & \ddot{q}_2 \end{bmatrix}^T\):
\begin{align*}
&\ddot{q} \xmapsto[\textnormal{permutation $Q$}]{} 
\begin{bmatrix}
  \ddot{q}_1 \\
  \ddot{q}_2
\end{bmatrix}
\xmapsto[\textnormal{mettre les $n_{\emph{fd}}$ premiers termes à 0}]{} 
\begin{bmatrix}
  0 \\
  \ddot{q}_2
\end{bmatrix}
\xmapsto[\textnormal{permutation inverse $Q^T$}]{} 
\left. \ddot{q} \right\vert_{\ddot{q}_1=0} = Q^T
\begin{bmatrix}
  0 \\
  \ddot{q}_2
\end{bmatrix} \\
\medskip
&\textnormal{et ...} \\
&\left. \ddot{q} \right\vert_{\ddot{q}_1=0} \xmapsto[C'=ID(q,\dot{q},\left. \ddot{q} \right\vert_{\ddot{q}_1=0})]{} C'
\xmapsto[\textnormal{permutation $Q$}]{} 
\begin{bmatrix}
  C'_1 \\
  C'_2
\end{bmatrix}
\end{align*}


\subsection{calcul de H11 (sous-matrice d'inertie)}
%description de la construction de H et optimisation par défaut "branch sparsity"

Il faut à présent construire la sous-matrice d'inertie $H_{11}$. Plusieurs méthodes sont proposées dans l'algèbre spatiale selon Featherstone (\cite{bib_featherstone} section 9.1) . La plus simple, moins performante, consiste à:
\begin{itemize}
\item[$\centerdot$] calculer la matrice $H$ complète
\item[$\centerdot$] la réordonner suivant la permutation $Q$: $H'=Q H Q^T$
\item[$\centerdot$] Et finalement extraire la sous-matrice $H_{11}$ = $(h_{ij})_{1 \leqslant i \leqslant n_{fd},1 \leqslant j \leqslant n_{fd}}$
\end{itemize}
\bigskip
La deuxième méthode, beaucoup plus performante dans le cas où $n_{\emph{fd}}$ est signicativement plus petit que $n_{dof}$, consiste à modifier l'algorithme \gls{acr_crba}, de sorte à le réduire aux seuls calculs produisant les termes de $H_{11}$. Cette méthode sera abordée en détail dans la section sur les optimisations \ref{ch_impl_optimisation}.

Nous avons choisi la première solution pour une première implémentation, dans le but de répartir la complexité de la tâche à entreprendre, et de se focaliser sur la validation des résultats numériques ainsi que de leurs précision.\\
\textbf{Remarque:} le \gls{acr_crba} original inclut déjà une première optimisation qui consiste à exploiter la sparsité de la matrice $H$, \cad à ne pas recalculer les termes nuls ($\forall q$) de $H$ induits par la topologie de l'arbre cinématique du robot. Plus précisément, cette sparsité est dûe à la nature des liaisons entre les corps du robot. Typiquement, pour deux corps $c_i$ et $c_j$ du système n'ayant aucun lien \emph{parent} - \emph{enfant} (voir chap. \ref{ch_algSpa_equationMouvement}), les coefficients respectifs dans la matrice d'inertie, $H_{ij}$ et $H_{ji}$, sont nuls.

\subsubsection{Implementation}

Cette étape ne présente aucune difficulté particulière. Nous enchaînons les opérations suivantes pour générer la matrice $H_{11}$:

\begin{equation*}
q \xmapsto[CRBA(modèle,q)]{} 
H 
\xmapsto[\textnormal{permutation $Q$ de matrice carrée}]{} 
Q H Q^T = 
\begin{bmatrix}
  H_{11} & H_{12} \\
  H_{21} & H_{22}
\end{bmatrix}
\xmapsto[\textnormal{extraire la matrice $H_{11}$ de $H$}]{} H_{11}
\end{equation*}

L'extraction de la matrice $H_{11}$ se fait simplement à l'aide d'une fonction \emph{Eigen} templatée, de copie de sous blocs de matrice.


\subsection{résolution du système linéaire}
%=> Eigen solver, ddq1

La relation matricielle \eqref{equ_equationMvt_dynHyb2} se décline en deux équations. La première nous permet de calculer ici $\ddot{q}_1$, et la deuxième nous permettra de calculer $\tau_2$ dans l'étape 5 de l'algorithme global. Calculons $\ddot{q}_1$:

\begin{equation}
H_{11} \ddot{q}_1 = \tau_1 - C'_1 \\
\iff \ddot{q}_1 = H_{11}^{-1} (\tau_1 - C'_1)
\end{equation}

Si $H_{11}$ est inversible. Justement, il est important de noter ici que \textbf{$H$ et $H_{11}$ sont définies positives et symétriques\footnotemark[1]}, et toute matrice définie positive est inversible \cite[ch.4.2]{bib_matrixComputation}. On connaît ces propriétés à la base pour $H$. Intéressons-nous alors aux propriétés de $H_{11}$ qui en découlent:
\begin{flushleft}
\begin{itemize}
\item[$\centerdot$] Symétrique:
\begin{equation*}
\textnormal{H est symétrique}  \iff   H = H^T \iff (Q H Q^T)^T = Q (Q H)^T = Q (H^T Q^T) = Q H Q^T
\end{equation*}
Donc la matrice permutée $Q H Q^T$ est également symétrique.\medskip
\item[$\centerdot$] Définie positive: une matrice réelle M carrée de dimension $n \times n$ est définie positive si $x^T H x > 0$ pour tout vecteur colonne $x$, réel et non nul \cite[ch.4.2]{bib_matrixComputation}:
\begin{align*}
\textnormal{H définie positive} \iff  &\forall x: x^T H x > 0 \\
\textnormal{or} \quad &x^T (Q H Q^T) x = (x^T Q) H ((Q^T x)^T)^T = (x^T Q) H (x^T Q)^T = y H y^T > 0 \quad \forall y \\
\implies &x^T (Q H Q^T) x > 0 \\
\textnormal{où} \quad &y = x^T Q \quad \textnormal{est un vecteur colonne réel quelconque.}
\end{align*}
Donc la matrice permutée $Q H Q^T$ est également définie positive.\medskip
\item[$\centerdot$] Par construction, la matrice carrée $H_{11}$ hérite de ces propriétés.
\end{itemize}
\end{flushleft}
\medskip
Ainsi, le calcul de $\ddot{q}_1$ peut passer par l'inversion directe de $H_{11}$ pour des systèmes de petite taille (quelques degrés de libertés). Mais pour des systèmes de grande taille, comme par exemple un robot humanoïde à 35 degrés de liberté,  il faudra résoudre le système linéaire définit comme suit:

\begin{align}
&A x = b \notag \\
&\textnormal{Avec:   $A = H_{11}$ ,  $b = \tau_1 - C'_1$  et  $x=\ddot{q}_1$}
\end{align}

Pour résoudre ce système d'équations linéaires, il faudra utiliser une méthode dite de décomposition de la matrice $A$. Il existe de nombreuses méthodes de décomposition en analyse numérique, souvent aussi appelées factorisations, dont le choix dépend d'une série de critères comme:
\begin{itemize}
\item[$\centerdot$] les conditions sur la nature de la matrice $A$ (carrée, inversible, définie positive, semi-définie positive, définie négative)
\item[$\centerdot$] un compromis entre la performance d'exécution, la précision et la stabilité ou robustesse. La robustesse mesure la fiabilité des résultats et à quel point la précision de ces résultats peut diverger en fonction des valeurs de la matrice $A$. Certaines décompositions nécessitent un pré-conditionnement de cette matrice qui peut changer sa nature (permutation de lignes, factorisation, etc)
\item[$\centerdot$] opérations supplémentaires sur la matrice $A$ en plus de la résolution du système linéaire
\item[$\centerdot$] des optimisations intrinsèques à l'algorithme comme le traitement de la matrice par blocs
\item[$\centerdot$] l'exploitation de la parallélisation dans les processeurs multi-cœur via l'OpenMP (\gls{gls_openMP} \cite{bib_openMpWikipedia} \cite{bib_openMPspecs}). Parallélisation implicite: l'algorithme exploite certaines routines parallélisées des processeurs (ex: produits de matrices). Parallélisation explicite: l'algorithme lui-même est parallélisé
\item[$\centerdot$] la disponibilité de l'algorithme dans les librairies de calcul qui seront utilisées dans ce projet (Eigen, Lapack).
\end{itemize}
\medskip
Une description un peu plus détaillée de ces algorithmes sera donnée par  la suite.

\subsubsection{Implémentation}


\paragraph{Choix des librairies d'outils et identification des algorithmes de résolution de système linéaire}.\\

\`{A} ce stade, les coefficients $A$ et $b$ du système d'équations linéaire $Ax=b$ sont connus. Il faut à présent choisir l'\textbf{algorithme de décomposition approprié} pour le résoudre. L'ensemble des composants logiciels liés à la plateforme robotique de \textbf{HRP2} utilisent majoritairement la librairie dynamique d'outils matriciels \emph{Eigen}. Parmi ces composant on distingue:
\begin{itemize}
\item la \emph{\gls{acr_sot}}, intégrée dans \textbf{HRP2}
\item la librairie \emph{metapod} d'algorithmes de dynamique directe et inverse (module actuellement indépendant, intégration dans la SOT à venir)
\item le composant dédié à la génération de mouvements (\emph{HPP})
\item le composant dédié à l'interface et la simulation dynamique du robot
\end{itemize}

En accord avec l'état de ces composants, et avec la stratégie de leur développement et maintenance menée par l'équipe \emph{Gepetto}, l'emploi des méthodes d'\emph{Eigen} était prioritaire dans la mesure de leur disponibilité et compatibilité avec la nature des algorithmes clients. J'ai dressé dans un premier temps la liste complète des algorithmes de décomposition fournis dans \emph{Eigen}, suivant les critères mentionnés plus haut. En voici la description résumée:

\begin{description}
\item[La décomposition LU:] il s"agit d'une méthode de décomposition d'une matrice comme produit d'une matrice triangulaire inférieure $L$ (comme "lower", inférieure) et d'une matrice triangulaire supérieure $U$ (comme "upper", supérieure): $A=LU$ \cite[ch.3.2]{bib_matrixComputation}
\item[Pivot LU ou PivLU] dans les cas où $A$ n'admet pas de décomposition $LU$. On applique alors une permutation aux lignes de $A$, et on obtient la forme: $A=PLU$, où $P$ est une matrice de permutation. Cette décomposition a deux versions, la partielle et la complète. La version complète a une approche générique, et entre autres, calcule le rang de la matrice $A$ et vérifie si celle-ci est inversible. La version partielle n'effectue pas cette vérification, et minimise les calculs nécessaires pour atteindre le résultat final. La version partielle est donc plus rapide, mais plus sensible aux erreurs d'arrondi \cite[ch.3.2]{bib_matrixComputation} section 1.3.1, pages 25-26.
\item[QR:] est de la forme: $A=Q R$, où $Q$ est une matrice orthogonale et $R$ une matrice triangulaire \cite[ch.5.2]{bib_matrixComputation}. Cette décomposition est souvent utilisée sur des systèmes linéaires non carrés, et permet, dans ces cas là, de calculer la pseudo-inverse de la matrice $A$.
\item[La factorisation de Cholesky(LLT):] n'est applicable qu'aux matrice symétriques définies positives. Elle décompose $A$ suivant la forme: $A = L L^T$, où $L$ est une matrice triangulaire inférieure. La $LLT$ permet de calculer l'inverse de $A$ ainsi que son déterminant.
\item[LDLT] est une variante de $LLT$. En évitant d'utiliser des résultats de calculs complexes de racine au sein de fractions, la $LDLT$ est plus robuste et potentiellement moins rapide.
\item[La décomposition Jacobienne SVD (Singular Value Decomposition):] décompose la matrice $A$ en vecteurs propres, et a la forme: $A = U \Sigma V^\ast$, où $\Sigma$ est la matrice diagonale rectangulaire contenant les valeurs propres de $A$, et où les matrices orthogonales $U$ et $V^\ast$ sont les vecteurs propres de $A$ à gauche et à droite. Cette décomposition permet également le calcul de la pseudo-inverse d'une matrice non carrée, le calcul du rang, etc. Elle est très utilisée dans des applications de traitement du signal. 
\end{description}

Et un tableau fourni sur le site de Eigen, regroupant les décompositions disponibles sous Eigen, avec leurs caractéristiques et contraintes:

\begin{table}[H]
\centering
\includegraphics[width=\textwidth]{figs/decompositionCatalogueEigen1.png}
\includegraphics[width=\textwidth]{figs/decompositionCatalogueEigen2.png}
\caption[Table caption text]{Liste et caractéristiques des décompositions proposées par Eigen \cite{bib_eigen_tutorial_catalogue}.}
\label{table:catalogue}
\end{table}

Tous ces algorithmes ont atteint une très bonne maturité d'implémentation dans la librairie \emph{Eigen}, à part FullPivHouseholderQR, qui est pourtant le plus robuste mais aussi plus lent. Parmi les plus rapides, on trouve les algorithmes de Cholesky, le LLT et le LDLT. Ils intègrent l'optimisation du traitement par blocs et bénéficient quand même d'une bonne fiabilité et précision. Leurs performances bénéficient des conditions les plus restrictives sur la matrice $A$:
\begin{itemize}
\item[\textbf{$\centerdot$ LLT:}] $A$ doit être définie positive et symétrique
\item[\textbf{$\centerdot$ LDLT:}] $A$ doit être semi-définie positive ou négative
\end{itemize}

%VERIFIER: propriétés de H énoncées en premier dans le chapitre (equation de mouvement)
Nous choisissons dans un premier temps l'algorithme le plus restrictif, \emph{LLT}, puisque comme vu précédemment, $H$ et $H_{11}$ sont définies positives. Cette décomposition est particulièrement efficace dans le cas de problèmes symétriques de la forme: $D^* D x = b$ \cite{bib_eigen_LLT_desc} où $D$ est une matrice diagonale. Le problème posé ici ne vérifie pas cette condition.
De plus, la décomposition \emph{LLT} devient instable si la matrice est semi-définie positive, or l'algorithme n'intègre pas la vérification de cette condition. Aussi, le calcul des termes de la matrice triangulaire $L$ utilise la division par des racines carrées, ce qui est une source potentielle d'instabilité. La décomposition \emph{LDLT} est plus robuste, évitant l'emploi de racines carrées, comme on peut voir dans comparaison des deux algorithmes ci-dessous:

\setlength{\intextsep}{0pt}
\setlength{\columnsep}{0cm}
\begin{wraptable}[7]{r}{0.45\textwidth}\raggedleft
\begin{tabular}[H]{|l|c|}
\hline
Décomposition ou méthode & Complexité $O$ \\ \hline \hline
inversion directe de matrice & $O(n^3)$ \\ \hline
LLT et LDLT & $O(n^3/3)$ \\ \hline
LU & $O(2n^3/3)$ \\ \hline
QR & $O(4n^3/3)$ \\
\hline
\end{tabular}
\end{wraptable}

\paragraph*{Complexités des différentes méthodes:}
Comparons ci-contre la complexité de calcul $O$ de ces décompositions avec celle de l'inversion directe de la matrice $A$, en fonction de la taille du problème (taille de la matrice à inverser). La complexité théorique est de loin la meilleure pour les décompositions $LLT$ et $LDLT$. Idéalement, il faudrait vérifier les performances de chacun d'elles sur notre système linéaire et vérifier dans chaque cas la stabilité et précision des résultats, ainsi que la vitesse d'exécution. Eigen fournit, à cet effet, une interface pour tester en ligne le système à résoudre. Nous avons choisit de tester certaines des décompositions de la librairie Eigen directement dans \emph{metapod}:
\begin{itemize}
\item[$\centerdot$] La variante \emph{ColPivHouseholderQR} de QR donnait des résultats assez imprécis. La variante \emph{FullPivHouseholderQR} donnait de meilleurs résultats pour les quelques vecteurs d'entrée de référence testés ($q, \dot{q}, \ddot{q}$) mais ces deux décomposition QR restent très lentes et ont donc été abandonnées rapidement dans notre approche.
\item[$\centerdot$] $LLT$  et $LDLT$ ont donné des résultats très satisfaisants en précision et vitesse de calcul. Ces résultats seront détaillés plus loin dans la section "tests unitaires"
\end{itemize}

\paragraph{Choix final:} La décomposition retenue a été la $LDLT$. La classe correspondante Eigen est:
\begin{verbatim}
Eigen::LDLT< _MatrixType, _UpLo >
\end{verbatim}
Où \verb;_MatrixType; est le type de la matrice $H$ (éléments à virgule flottante, taille $n_{fd} \times n_{fd}$) et \verb;_UpLo; est la partie triangulaire de $H$ qui sera utilisée dans la décomposition (par défaut la partie inférieure). On instancie cette classe en passant au constructeur la matrice à décomposer $H$. On résout ensuite le système en appelant la méthode \verb;solve; :
\begin{verbatim}
Eigen::LDLT<TypeOfMatrixH11> ldltOfH11(H11);
ddq1 = ldltOfH11.solve(tau1 - C1prime);
\end{verbatim}


\subsection{résolution de $\mathbf{\tau_2}$ et reconstruction des vecteurs de sortie ddq et tau} \label{ch_impl_calculTau2}

Nous reprenons maintenant la deuxième équation du système linéaire \eqref{equ_equationMvt_dynHyb2}:
\begin{align}
&H_{21} \ddot{q}_1 - \tau_2 = -C'_2 \notag \\
\iff
&\tau_2 = C'_2 + H_{21} \ddot{q}_1 \label{equ_tau}
\end{align}

Cette équation représente la deuxième ligne de la relation matricielle proposée par Featherstone \cite{bib_featherstone} section 9.1 page 173:

\begin{align}
\eqref{equ_equationMvt_dynHyb1}
&\iff
\begin{bmatrix}
\tau_1 \\ 
\tau_2
\end{bmatrix} 
=
\begin{bmatrix}
C'_1 \\ 
C'_2
\end{bmatrix} 
+
\begin{bmatrix}
H_{11} \ddot{q}_1 \\ 
H_{21} \ddot{q}_1
\end{bmatrix} \iff
Q^T
\begin{bmatrix}
\tau_1 \\ 
\tau_2
\end{bmatrix} 
=
Q^T
\begin{bmatrix}
C'_1 \\ 
C'_2
\end{bmatrix} 
+
Q^T
\begin{bmatrix}
H_{11} \ddot{q}_1 \\ 
H_{21} \ddot{q}_1
\end{bmatrix} \iff \tau = C'
+
Q^T
\begin{bmatrix}
H_{11} \ddot{q}_1 \\ 
H_{21} \ddot{q}_1 \label{equ_tauIDdiff}
\end{bmatrix}
\end{align}


\subsubsection{Implémentation}

Les éléments $C'_2$, $QHQ^T$ et $\ddot{q}_1$ sont connus. On extrait $H_{21}$ de la matrice $QHQ^T$. On calcule $\tau_2$ suivant \eqref{equ_tau}, on le concatène à $\tau_1$ et on restitue l'ordre initial des variables. On fait de même pour $\ddot{q}_1$, $\ddot{q}_2$ et $\ddot{q}$.
On récapitule ci-dessous l'ensemble des 5 étapes de l'algorithme: \\

\shadowbox{\small%
\begin{minipage}[t]{\textwidth}
\setlength{\columnsep}{10pt}
\setlength{\columnseprule}{0.5pt}
\begin{multicols}{2}\raggedcolumns
\begin{spacing}{1.5}
\begin{pseudocode}{hybridDynamics}{model, q, \dot{q}, \ddot{q}, \tau}
(1)
\BEGIN
  \textnormal{\# Calul de $C'$, $C'_1$ et $C'_2$} \\
  \ddot{q}_{perm} \GETS Q \ddot{q} \\
  (\ddot{q}_{perm})_{i \in [1,\emph{fd}]} \GETS 0 \\
  \ddot{q}_2 \GETS (\ddot{q}_{perm})_{i \in [\emph{fd}+1,n_{dof}]} \\
  \ddot{q} \GETS Q^T \ddot{q}_{perm} \\
  model.torques \GETS rnea(model,q,\dot{q},\ddot{q}) \\
  C' \GETS getTorques(model) \\
  C'_{perm} \GETS Q C'\\
  C'_1 \GETS (C'_{perm})_{i \in [1,\emph{fd}]} \\
  C'_2 \GETS (C'_{perm})_{i \in [\emph{fd}+1,n_{dof}]}
\END \\
(2)
\BEGIN
  \textnormal{\# Calcul de $H_{11}$} \\
  model.H \GETS crba(model,q) \\
  H_{perm} \GETS Q model.H Q^T \\
  H_{11} \GETS (H_{perm})_{i,j \in [1,\emph{fd}]} \\
\END \\
\end{pseudocode}
\begin{pseudocode}[display]{}{}
(3)
\BEGIN
  \textnormal{\# Résolution de l'équation $H_{11} \ddot{q}_1 = \tau_1 - C'_1$} \\
  \tau_{perm} \GETS Q \tau \\
  \tau_1 \GETS (\tau_{perm})_{i \in [1,\emph{fd}]} \\
  \tau_2 \GETS {i \in [\emph{fd}+1,n_{dof}]} \\
  b \GETS \tau_1 - C'_1
  A \GETS H_{11} \\
  lltOfH11 \GETS LLT(A) \hfill \textnormal{\# création du solveur} \\
  \ddot{q}_1 \GETS lltOfH11.solve(b) \hfill \textnormal{\# résolution} \\
\END \\
(4)
\BEGIN
  \textnormal{\# Calcul de $\tau_2$ et reconstruction des vecteurs de} \vspace{-0.2cm} \\
  \textnormal{\# sortie $\ddot{q}$ et $\tau$} \\
   H_{21} \GETS (QHQ^T)_{n_{\emph{fd}+1} \leqslant i \leqslant n_{dof},1 \leqslant j \leqslant n_{\emph{fd}}} \\
  \tau_2 \GETS C'_2 + H_{21} \ddot{q}_1 \\
  \tau \GETS Q^T \begin{bmatrix} \tau_1 & \tau_2 \end{bmatrix}^T \\
  \ddot{q} \GETS Q^T \begin{bmatrix} \ddot{q}_1 & \ddot{q}_2 \end{bmatrix}^T
\END
\end{pseudocode}
\end{spacing}
\end{multicols}
\end{minipage}}


\section{mesure de performances et optimisations de l'algorithme} \label{ch_impl_optimisation}

\setmyFiguresFile{optimisations}

\subsection{jcalc et le calcul des matrices de passage $^sX_p$}

\verb;jcalc(); est la fonction appelée pour mettre à jour les matrices de passage $^sX_p$ entre les repères liés aux deux corps $p$ (prédécesseur) et $s$ (successeur) pour chaque articulation du robot. Ces matrices $^sX_p$ sont incluses dans la classe $model$ (modèle du robot), et générées avec ce modèle à la compilation de \emph{metapod}. Elles peuvent être générées comme des matrices génériques: ce sont alors des structures templatées qui peuvent définir n'importe quel axe de rotation suivant ce qu'on leur passe en paramètre à kleur instanciation. Sinon, elles peuvent être définies comme des matrices spéciales, simplifiées, dont l'axe est parallèle à un des axes $(Ox)$, $Oy$  ou $Oz$ du repère lié au corps $s$. Ces matrices $^sX_p$ sont dites à axes fixes. Elles permettent d'accélérer significativement les calculs matriciels dans lesquels elles sont impliquées. Cela est dû au fait qu'elles soient creuses. Pour exploiter cette "sparsité", des règles spécifiques de produit matriciel ont été définies. Le version officielle servant de base à mon développement avait une erreur au niveau des fonction définissant ces règles de calcul.Cette correction a été la première à être intégrée dans la version officiele de \emph{metapod}.

\subsection{Permutation optimale sous Eigen des variables et coefficients de l'équation de mouvement}


\subsection{"branch sparsity" et "$\nu(\emph{fd})$ sparsity" dans l'algorithme CRBA (calcul de optimisé $H$)}

Nous allons à présent optimiser le calcul des éléments d'inertie du système. Au lieu de calculer la totalité des termes de $H$, pour en extraire les sous-matrices $H_{11}$ et $H_{21}$ nécessaires à l'algorithme, nous calculons uniquement les termes de ces sous-matrices. Regardons de près l'algorithme \gls{acr_crba} original.\\

\subsubsection{Principe du CRBA}
Celui-ci calcule tous les termes de $H$ et est déjà optimisé par rapport à la \gls{gls_sparsite} de la matrice induite par la structure ramifiée de l'arbre cinématique du robot. Le CRBA parcours cet arbre en profondeur d'abord, ce qu'on désigne par un parcours \gls{acr_algoDFS}. L'inertie de chaque corps est initialisée dans le sens descendant de la base (corps 0) vers les feuilles. L'inertie composite de chaque corps assimilé au sous-arbre qu'il supporte est calculée par récursivité dans le sens ascendant des feuilles vers le corps 0. Dans le cas d'un robot humanoïde, le corps 0 pourrait être assimilé au torse, et les feuilles aux mains et aux pieds. S'il n'existe pas de chemin toujours ascendant reliant deux corps $c_i$, $c_j$ à la base $c_0$, alors les termes associés $H_{ij}$ et $H_{ji}$ sont nuls.\\
Avant de continuer, il est indispensable de tenir compte des concepts fondamentaux sur la représentation des arbres cinématiques \cite{ch_algSpa_equationMouvement}:

\begin{itemize}
\item $p(i)$ est le noeud \emph{prédécesseur} et $s(i)$ est le noeud \emph{successeur} de l'articulation $i$
\item $\lambda(i)$ est le noeud \emph{parent} du corps $i$
\item $\forall i \neq 0: \kappa(i)$ est l'ensemble des noeuds sur le chemin entre le noeud $i$ et la base (noeud $0$)
\item $\forall i: \mu (i)$  est l'ensemble des enfants du noeud $i$
\item $\forall i: \nu (i)$  est l'ensemble des noeuds supportés par l'articulation $i$, ou encore, inclus dans le sous-arbre suspendu au noeud $i$
\end{itemize}

Considérons l'arbre cinématique suivant, à l'aide duquel on illustre les ensembles qu'on vient de décrire.\\

\begin{figure}[H]
\minipages[2]{c}{.5}{.5}{}
{%
  \begin{center}
  	\incFig[1]{0.8\textwidth}
  	\end{center}
}
{%
  \begin{center}
  	\begin{tabular}{|c|c|c|c|c|c|c|c|}
  	\hline 
	articul. $i$ & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\ 
  	\hline 
  	$p$ & 0 & 1 & 1 & 2 & 2 & 3 & 3 \\ 
  	\hline 
  	$s$ & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\ 
  	\hline 
  	$\lambda$ & 0 & 1 & 1 & 2 & 2 & 3 & 3 \\ 
  	\hline 
  	\end{tabular} 
  \end{center}
}{}
\caption{$p$, $s$, $\lambda$, $\kappa$, $\mu$ et $\nu$ dans l'arbre cinétique}
\label{fig_chdaArbreK_p_s_k_mu_nu}
\end{figure}

Voici les équations fondamentales à la base de l'algorithme \gls{acr_crba}, telles que présentées par Featherstone (\cite{bib_featherstone} chap. 6.2):

\minipages[2]{c}{.3}{.68}{}
{%
  \dispFig[H]{3}{0.8\textwidth}{Exemples de $H_{ij}$ dans l'arbre cinématique.}{fig_chdaArbreK2}
}
{%
  \fbox{
  \begin{minipage}[c]{0.9\textwidth}
	\begin{align}
	I_i^c &= \sum_{j \in \nu(i)}I_j \label{equ_inertieComposite} \\
	H_{ij} &= \sum_{k \in \nu(i) \cap \nu(j)}\mathbf{{S_i^T} I_k S_j}
	\implies
	H_{ij} = 
	\begin{cases}
	\mathbf{S_i^T \: I_i^c \: S_j} \quad \textnormal{if} i \in \nu(j) \\
	\mathbf{S_i^T \: I_j^c \: S_j} \quad \textnormal{if} j \in \nu(i) \\
	\mathbf{0} \quad \textnormal{otherwise}
	\end{cases} \label{equ_momentInertieComposite}
	\end{align}
  \end{minipage}
  }
}{}

Où tous les éléments sont exprimés dans le repère base $R_0$ lié au corps $0$. $I_i^c$ est l'inertie composite du corps $i$. Elle représente l'inertie équivalente du sous-arbre $\nu(i)$ supporté par le corps $i$. C'est cette grandeur d'inertie composite qui donne le nom à l'algorithme. Les éléments d'inertie $H_{ij}$ sont calculés à partir des inerties composites et des matrices $S$ dites de "sous-espace de mouvement" ou encore matrices de sélection des articulations. On rappelle  la définition de la matrice de sélection $S$ d'une articulation (section \ref{ch_algSpa_transformations}). Si $v_J$ est la vitesse du corps $k$ par rapport au corp parent $\lambda(k)$ (dite aussi "vitesse à travers l'articulation $k$"), exprimée dans le repère $R_k$ lié au corps $k$, et si $\dot{q}_i$ est la vitesse articulaire, on a alors:
\begin{equation}
{^kv_J} = {^kS_k} \: \dot{q}_k
\end{equation}
On montre assez simplement que $H$ est symétrique. En effet, la relation \eqref{equ_momentInertieComposite} nous donne:
\begin{equation}
{H_{ij}^T} = \left( \sum_{k \in \nu(i) \cap \nu(j)}\mathbf{{S_i^T} I_k S_j} \right)^T 
= \sum_{k \in \nu(i) \cap \nu(j)}\left( \mathbf{{S_i^T} I_k S_j} \right)^T 
= \sum_{k \in \nu(i) \cap \nu(j)}\mathbf{{S_j^T} I_k S_i}
\end{equation}
Or, en échangeant les valeurs $i$ et $j$, on obtient:
\begin{equation}
H_{ji} = \sum_{k \in \nu(j) \cap \nu(i)}\mathbf{{S_j^T} I_k S_i} = \sum_{k \in \nu(i) \cap \nu(j)}\mathbf{{S_j^T} I_k S_i} = {H_{ij}^T}
\end{equation}
\textbf{La matrice d'inertie $H$ est donc symétrique}, ce qui nous permet de ne calculer que la moitié de ses éléments.

Regardons de près comment le CRBA les calcule de façon optimale. Dans les relations \eqref{equ_inertieComposite} et \eqref{equ_momentInertieComposite}, tous les éléments sont exprimés dans le repère base $R_0$. Mais l'algorithme \gls{acr_crba} a été écrit de sorte à exploiter le calcul récursif. En effet, pour chaque itération de calcul sur le corps $i$, l'algorithme utilise l'expression des torseurs dans la base liée à ce même corps. \textbf{Cela permet d'éviter le calcul des matrices de passage $^0X_i$ pour chaque corps $i$ ainsi que le calcul des termes $I$ et $S$ dans le repère $R_0$}.

\subsubsection{calcul récursif de $I_i^c$}

$I_i^c$ est initialement définie comme la somme des inerties de l'ensemble $\nu(i)$. Mais elle est calculée résursivement en remontant l'arbre des feuilles jusqu'au noeud $i$ compris. Chaque fois qu'un corps $j$ est visité, son inertie est rajoutée au noeud parent $\lambda(j)$, qui cumule ainsi toute l'inertie du sous-arbre qu'il supporte. On exprime chacune des inerties $I_j^c$ dans le repère du corps $j$. \\

\minipages[2]{c}{.3}{.67}{}
{%
  \dispFig[H]{2}{0.7\textwidth}{$k$, $\mu$ et $\nu$ dans l'arbre cinématique.}{fig_chdaArbreK3}
}
{%
  \begin{alignat}{2}
  &\textnormal{(dans le repère $R_0$)} \quad &&{I_i^c} = \sum_{j \in \nu(i)}I_j = I_i + \sum_{j \in \mu(i)}I_j^c \label{equ_inertieCompositeRecurs} \\
  &\textnormal{(dans le repère $R_i$)} \quad \iff &&{I_i^c} = I_i + \sum_{j \in \mu(i)} {^iX_j^*} \: {I_j^c} \: {^jX_i} \label{equ_inertieCompositeLocale}
  \end{alignat}
}{}

On présente ci-dessous deux versions (a) et (b) de l'algorithme de calcul récursif, tels que proposées par Featherstone (\cite{bib_featherstone} chap.6.2 p.108):

\begin{minipage}[t]{0.5\textwidth}
    (a) Mise à jour des noeuds enfants du noeud visité... \\
    	\begin{spacing}{1.5}
		\begin{pseudocode}[display]{}{}
		\FOR i \GETS N_B \DOWNTO 1 \DO
		\BEGIN
		  I_i^c = I_i \\
		  \FOREACH j \in \mu(i) \DO
		    I_i^c \GETS I_i^c + {^iX_j^*} \: {I_j^c} \: {^jX_i}
		\END
	  \end{pseudocode}
	  \end{spacing}
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
    (b) Mise à jour du noeud parent du noeud visité. \\
    	\begin{spacing}{1.5}
		\begin{pseudocode}[display]{}{}
		\FOR i \GETS 1 \TO N_B \DO
		  I_i^c = I_i \\
		\FOR i \GETS N_B \DOWNTO 1 \DO
		\BEGIN
		  \IF \lambda(i) \neq 0
		  \THEN
		    I_{\lambda(i)}^c \GETS I_{\lambda(i)}^c + {^{\lambda(i)}X_i^*} \: {I_i^c} \: {^iX_{\lambda(i)}}
		\END
	  \end{pseudocode}
	  \end{spacing}
\end{minipage}
\bigskip
Dans les deux algorithmes, on met à jour les inerties composites en remontant l'arbre des feuilles à la racine. Dans l'algorithme (a), chaque noeud visité est traité en une seule fois. L'inconvénient est que ce n'est pas adapté à un parcours en profondeur de l'arbre cinématique. Or la librairie \emph{metapod} a la majorité de ces outils et algorithmes dynamiques basés sur le parcours \gls{acr_algoDFS}.\\
Justement, l'algorithme (b) est lui, plus proche du parcours en profondeur. Par un changement de variable, on se place du point de vue d'un noeud enfant. Chaque noeud enfant visité met à jour son noeud parent. La condition nécessaire pour que ces deux versions (a) et (b) soient valables est qu'un noeud $i$ donné n'est jamais visité avant un de ces noeuds parents. C'est justement le cas d'après la méthode de représentation et numérotation présentée par Featherstone (\cite{bib_featherstone} chap.4, section 4.1.2), et le cas du parcours \gls{acr_algoDFS}.

\subsubsection{calcul récursif de $H_{ij}$ et algorithme global du CRBA}

Comme pour le calcul de l'inertie composite, nous commençons par faire apparaître dans l'expression de $H_{ij}$ (\eqref{equ_momentInertieComposite} les termes $I$ et $S$ exprimés dans leur repère propre. Nous remplaçons donc ${^0I_j^c}$ par ${^iX_j^*} \: {I_j^c} \: {^jX_i}$ où ${I_j^c}$ est exprimée dans son repère propre (repère lié au corps $j$). Aussi, on obtient, pour les composantes du calcul de $H_{ij}$:\\

\begin{tabular}{lccccccccccc}
($S$ et $I$ exprimés dans $R_0$) &   &\multicolumn{2}{c}{$ S_i^T $}&\multicolumn{3}{c}{$ I_i^c $}&\multicolumn{3}{c}{$ {S_j} $} \\ 
                                                        &   &\multicolumn{2}{c}{$\overbrace{\hspace{1.5cm}}$}&\multicolumn{3}{c}{$\overbrace{\hspace{3cm}}$}&\multicolumn{3}{c}{$\overbrace{\hspace{1.5cm}}$} \\ 
($S$ et $I$ exprimés dans $R_i$) & = &$ S_i^T $&$ ^0X_i^T $&$ ^0X_i^* $&$ I_i^c $&$ ^iX_0 $&$ ^0X_i $&$ ^iX_j $&$ S_j $ \\ 
                                                       & = &$ S_i^T $&$ ^0X_i^T $&$ ^0X_i^{-T} $&$ I_i^c $& \multicolumn{2}{c}{$E$} &$ ^iX_j $&$ S_j $ \\ 
                                                       & = &$ S_i^T $&\multicolumn{2}{c}{$E$}&$ I_i^c $& \multicolumn{2}{c}{$E$} &$ ^iX_j $&$ S_j $ & $ \mathbf{= {S_i^T} \: {I_i^c} \: {^iX_j} S_j} $ \\ 
\end{tabular} \\

\begin{flushleft}
De même on montre que $\mathbf{S_i^T \: I_j^c \: S_j}$ avec $I$ et $S$ exprimés dans $R_0$ équivaut à $\mathbf{{S_i^T} \: {^iX_j^*} \: {I_j^c} \: S_j}$ avec $I$ et $S$ expimés dans $R_i$. On obtient donc $H_{ij}$ exprimé dans le repère lié au corps $i$:
\end{flushleft}

\begin{equation}
H_{ij} = 
\begin{cases}
\mathbf{{S_i^T} \: {I_i^c} \: {^iX_j} S_j} & \textnormal{if } i \in \nu(j) \\
\mathbf{{S_i^T} \: {^iX_j^*} \: {I_j^c} \: S_j} & \textnormal{if } j \in \nu(i) \\
\mathbf{0} & \textnormal{otherwise}
\end{cases} \label{equ_momentInertieCompositeLocal}
\end{equation}

Regardons comment le calcul de $H_{ij}$ est optimisé dans l'algorithme CRBA. On commence par exploiter la symétrie de la matrice $H$

\paragraph{symétrie de $H$:}
À la base, nous voulons calculer les termes $H_{ij}$ pour tous les arrangements possibles de couples $(i,j)$ de noeuds tels que $1 \leqslant i,j \leqslant N_B$. Pour un couple donné $(i,j)$, si $i \in \nu(j)$, alors $H_{ij}$ est calculé via le premier cas de l'équation \eqref{equ_momentInertieCompositeLocal}. Si $j \in \nu(i)$, on tombe encore dans le premier cas si on calcule cette fois-ci $H_{ji}$ (après un simple changement de variable $i \leftrightarrow j$). Or on a vu précédemment que $H_{ij}={H_{ji}^T}$:
\begin{equation}
H_{ij} = 
\begin{cases}
\mathbf{{S_i^T} \: {I_i^c} \: {^iX_j} S_j} & \textnormal{if } i \in \nu(j) \\
\mathbf{H_{ji}^T} & \textnormal{if } j \in \nu(i) \\
\mathbf{0} & \textnormal{otherwise}
\end{cases} \label{equ_momentInertieCompositeLocal2}
\end{equation}
\begin{flushleft}
Donc si on calcule tous les termes $H_{ij}$ et leur transposée $H_{ij}^T$ tels que $i \in \nu(j)$, on couvre tous les termes de $H$, hormis les termes nuls ($3^0$ cas de figure). On aurait pu choisir de calculer tous les termes $H_{ij}$ tels que $j \in \nu(i)$ et leurs transposées, mais nous verrons par la suite que le premier choix est plus efficace.
\end{flushleft}
\dispFig[H]{4}{0.8\textwidth}{Termes $H_{ij}$ tels que $i \in \nu(j)$, et leurs transposées, couvrant toutes les combinaisons entre les noeuds de $\kappa(7)$}{fig_symetrieH}

\paragraph{termes constants dans le parcours remontant $\nu(j)$:}
Nous allons donc calculer tous les $H_{ij}$, tels que $i \in [1,N_B]$ et $j \in \kappa(i)$. C'est à dire que pour $i$ fixé, on parcours l'arbre en remontant de parent en parent. On constate alors que le produit $\mathbf{{S_i^T} \: {I_i^c} \: {^iX_j} S_j}$ a un terme constant lors du parcours ascendant de l'arbre: $\mathbf{{S_i^T} \: {I_i^c}}$. Celui-ci est multiplié à droite par la matrice de passage $^iX_j$. Afin d'avoir la matrice de passage plutôt à gauche, on utilise la transposé de $\mathbf{{S_i^T} \: {I_i^c}}$:
\begin{align}
{^iF_i} &= {I_i^c} \: S_i \\
{^jF_i} &= {^jX_i^*} \: {I_i^c} \: S_i \iff {^jF_i}^T = {S_i^T} \: {I_i^c}^T \: {^jX_i^{-T}}^T = {S_i^T} \: {I_i^c} \: {^iX_j} \\
\iff H_{ij} &= {^jF_i}^T \: S_j
\end{align}

\vspace{0.5cm}

\setlength{\columnseprule}{0.5pt}
\begin{multicols}{2}\raggedcolumns
\begin{flushleft}
Donc, 
\begin{align*}
&\forall i \in [1,N_B] \\
&\begin{cases}
  \textnormal{on calcule:} & ^iFi = {I_i^c} \: S_i \\
  \textnormal{on calcule récursivement:} & {^{\lambda(j)}F_i}  =  {^{\lambda(j)}X_j^*} \: {^jF_i} \\
  \textnormal{(avec au départ $j=i$)} & H_{i{\lambda(j)}} = {^{\lambda(j)}F_i}^T \: S_{\lambda(j)} , \\
                                                          & \quad H_{{\lambda(j)}i} = H_{i{\lambda(j)}}^T
\end{cases}
\end{align*}

\vspace{0.5cm}

On présente ci-dessous l'algorithme global \gls{acr_crba} tel que présenté par Featherstone (\cite{bib_featherstone} chap.6, section 6.2 p.107):
\end{flushleft}

    	\begin{spacing}{1.5}
		\begin{pseudocode}{CRBA - Featherstone}{model,q} \label{algo_crbaFeatherstone}
    H = 0 \\
		\FOR i \GETS 1 \TO N_B \DO
		  I_i^c = I_i \\
		\FOR i \GETS N_B \DOWNTO 1 \DO
		\BEGIN
		  \IF \lambda(i) \neq 0
		  \THEN
		    I_{\lambda(i)}^c \GETS I_{\lambda(i)}^c + {^{\lambda(i)}X_i^*} \: {I_i^c} \: {^iX_{\lambda(i)}} \\
		  F \GETS {I_i^c} \: S_i \\
		  H_{ii} \GETS {S_i^T} F \\
		  j \GETS i \\
		  \WHILE \lambda(j) \neq 0 \DO
		  \BEGIN
		    F \GETS {^{\lambda(j)}X_j^*} F \\
		    j \GETS \lambda(j) \\
		    H_{ij} \GETS F^T S_j \\
		    H_{ji} \GETS H_{ij}^T
		  \END
		\END
	  \end{pseudocode}
	  \end{spacing}

\end{multicols}

\vspace{0.5cm}

\paragraph{Implémentation:}
On implémente l'algorithme \ref{algo_crbaFeatherstone} sous \emph{metapod} comme suis:
\begin{flushleft}
\shadowbox{\small%
\begin{minipage}[t]{\textwidth}
\setlength{\columnsep}{10pt}
\setlength{\columnseprule}{0.5pt}
\begin{multicols}{2}\raggedcolumns
    	\begin{spacing}{1.5}
		\begin{pseudocode}{CRBA - metapod}{model,q}
		\PROCEDURE{crbaDfsVisitor.discover}{model,i}
		  I_i^c \GETS I_i
		\ENDPROCEDURE \\
		\PROCEDURE{crbaDfsVisitor.finish}{model,i}
		  \IF \lambda(i) \neq 0
		  \THEN
		    I_{\lambda(i)}^c \GETS I_{\lambda(i)}^c + {^{\lambda(i)}X_i^*} \: {I_i^c} \: {^iX_{\lambda(i)}} \\
		  F_i \GETS {I_i^c} \: S_i \\
		  H_{ii} \GETS {S_i^T} F_i \\
		  \CALL{BackwardTraversalPrev}{crbaBckwrdVisitor, \vspace{-0.2cm}\\
		                               model,i,0}
		\ENDPROCEDURE
	  \end{pseudocode}
    
		\begin{pseudocode}[display]{}{}
		\PROCEDURE{crbaBckwrdVisitor.discover}{model,j,j_{prev}}
		    \textnormal{\# $j=\lambda(j_{prev})$. Et lors du premier appel, $j_{prev}=i$.} \\
		    F_i \GETS {^jX_{j_{prev}}^*} F_i \\
		    H_{ij} \GETS {F_i^T} S_j \\
		    H_{ji} \GETS H_{ij}^T
		\ENDPROCEDURE \\
		\PROCEDURE{crbaBckwrdVisitor.finish}{model,j,j_{prev}}
		    \textnormal{Do nothing}
		\ENDPROCEDURE \\
		\MAIN
    H \GETS 0 \\
    jcalc(model,q,\dot{q} \GETS 0) \\
    \CALL{DepthFirstTraversal}{crbaDfsVisitor,model,0}
    \ENDMAIN
	  \end{pseudocode}
	  \end{spacing}
\end{multicols}
\end{minipage}}
\end{flushleft}
\bigskip

\paragraph{\textsc{DepthFirstTraversal}, \textsc{BackwardTraversalPrev} et les visiteurs:}
On a introduit le principe de ces fonctions dans la section \ref{ch_concepts_visiteurs}. On s'intéresse, dans la suite, aux traitements spécifiques au CRBA  effectués dans les visiteurs.

\paragraph{\textsc{crbaDfsVisitor.discover}:}
On initialise ici toutes les inerties individuelles des différents noeuds (corps).

\paragraph{\textsc{crbaDfsVisitor.finish}:}
Pour le noeud $i$ visité, tous ses enfants ont été explorés, par conséquent l'inertie composite $I_i^c$ est à jour. Elle peut donc être ajoutée à celle du noeud parent. On peut également calculer ici toutes les valeurs dépendantes de $I_i^c$: $F_i$ et l'ensemble des $H_{ij}$. Notez que $F_i$ est utilisé comme un buffer et contient la dernière valeur calculée de $^jF_i$. $F_i$ est alors un champ lié au corps $i$.

\paragraph{\textsc{crbaBckwrdVisitor.discover} et \textsc{crbaBckwrdVisitor.finish}:}
Le parcours remontant vers la racine pour calculer les termes $F_i$ et $H_{ij}$ (boucle \textbf{"while"} de l'algorithme \ref{algo_crbaFeatherstone}) se fait entièrement à "l'aller", donc dans la fonction \textsc{...discover}. La fonction \textsc{...finish} (le chemin de retour) est donc vide. \\


Nous allons aborder maintenant l'optimisation proposée par Featherstone qui réduit le calcul de la matrice $H$ au seuls termes qui constituent la sous-matrice $H_{11}$. Et finalement, nous allons voir comment cette optimisation a été adaptée à l'algorithme CRBA de metapod, ainsi que les modifications supplémentaires pour le calcul de $H_{21}$.


\subsubsection{Modifications de CRBA pour le calcul de H11 optimisé}

Nous avions défini \emph{fd} comme l'ensemble des articulations en mode "dynamique directe", \cad pour lesquelles on connaît le couple ou les forces appliquées. Nous avions défini également l'ensemble complémentaire $\emph{id}$. \emph{fd} et \emph{id} désignent aussi chacun des corps directement supporté par chacune de ces articulations. Tous les termes $H_{ij}$ tels que $i,j \in \emph{fd}$ sont inclus dans la matrice $H_{11}$. Par conséquent, dans l'algorithme CRBA \ref{algo_crbaFeatherstone}: \\
\begin{itemize}
\item[$\centerdot$] on ne doit effectuer les lignes de calcul $H_{ij} = F S_j$ et $H_{ji} = H_{ij}^T$ que si $i,j \in \mathit{fd}]$
\item[$\centerdot$] dû au calcul récursif du paramètre $^jF_i$, celui-ci doit être calculé sur le parcours ascendant (boucle "\textbf{while}") tant que $\exists j$ tel que $j \in \kappa(i)$ et $j \in \mathit{fd}$, autrement dit, jusqu'au noeud \emph{fd} le plus proche de la racine\footnotemark[1]
\item[$\centerdot$] $H_{ii}$ et $^iF_i$ ne se calculent naturellement que si $i \in \mathit{fd}$
\item[$\centerdot$] $I_i^c$ étant calculé récursivement, subit la même contrainte que $^jF_i$, il doit être calculé tant que $\exists j$ tel que $j \in \kappa(i)$ et $j \in \mathit{fd}$\footnotemark[1]
\end{itemize}

\footnotetext[1]{On définit dans ce contexte le nouvel ensemble $\nu(\mathit{fd})$.}
\medskip
Pour déterminer le domaine de calcul de $I_i^c$ et $^jF_i$, on introduit (\cite{bib_featherstone} table 9.1, equation 9.5) l'ensemble $\nu(\emph{fd})$ comme étant l'ensemble des noeuds supportés par au moins une articulation \emph{fd}, \cad l'ensemble des sous-arbres supportés par une articulation \fd:
\begin{equation}
\nu(\mfd) = \bigcup_{i \in \mfd}\nu(i)
\end{equation}

\begin{minipage}[c]{0.5\textwidth}
  \dispFig[H]{5}{0.7\textwidth}{Exemple de $\nu(fd)$ dans l'arbre cinématique. Le noeud 1 n'appartient pas à $\nu(fd)$}{fig_chdaArbreK_nuFD}
\end{minipage}
\begin{minipage}[c]{0.5\textwidth}
    On calcule alors $\nu(fd)$ par récurrence:
    \begin{spacing}{1.5}
	  \begin{pseudocode}[display]{}{}
    \nu(\mfd) = \mfd \\
		\FOR i \GETS 1 \TO N_B \DO
		\BEGIN
		  \IF \lambda(i) \in \nu(\mfd)
		  \THEN
		    \nu(\mfd) \GETS \nu(\mfd) \cup {i}
		\END
    \end{pseudocode}
    \end{spacing}
\end{minipage}

\begin{flushleft}
Une des propriétés importantes de $\nu(fd)$ à retenir est:
\begin{equation*}
j \notin \nu(fd) \implies \forall n \in \kappa(j), n \notin \nu(fd)
\end{equation*}

La conséquence de cette propriété est qu'il est inutile de calculer les termes $^jF_i$ et $I_i^c$ au-delà de la racine de l'ensemble $\nu(fd) \cap \kappa(i)$.
\end{flushleft}

Nous pouvons à présent écrire, ci-contre, l'algorithme complet CRBA optimisé pour $H_{11}$, suivant Featherstone (\cite{bib_featherstone} table9.1):\\

\begin{minipage}[t]{\textwidth}
\setlength{\columnsep}{10pt}
\setlength{\columnseprule}{0.5pt}
\begin{multicols}{2}\raggedcolumns\small
    	\begin{spacing}{1.5}
		\begin{pseudocode}{CRBA - Featherstone}{model,q} \label{algo_crbaFeatherstoneH11}
    H \GETS 0 \\
		\FOREACH i \in \nu(fd) \DO
		  I_i^c \GETS I_i \\
		\FOR i \GETS N_B \DOWNTO 1 \DO
		\BEGIN
		  \IF \lambda(i) \in \nu(fd)
		  \THEN
		    I_{\lambda(i)}^c \GETS I_{\lambda(i)}^c + {^{\lambda(i)}X_i^*} \: {I_i^c} \: {^iX_{\lambda(i)}} \\
		  \ldots
		\END
	  \end{pseudocode}
	  
	  \begin{pseudocode}[display]{}{}
	  \DO
    \BEGIN
      \ldots \\
		  \IF i \in fd \THEN
		  \BEGIN
			  F \GETS {I_i^c} \: S_i \\
			  H_{ii} \GETS {S_i^T} F \\
			  j \GETS i \\
			  \WHILE \lambda(j) \in \nu(fd) \DO
			  \BEGIN
			    F \GETS {^{\lambda(j)}X_j^*} F \\
			    j \GETS \lambda(j) \\
			    \IF j \in fd \THEN
			    \BEGIN
				    H_{ij} \GETS F^T S_j \\
				    H_{ji} \GETS H_{ij}^T
			    \END
			  \END
			\END
		\END
	  \end{pseudocode}
	  \end{spacing}
\end{multicols}
\end{minipage} \vspace{0.3cm} \\

\paragraph{Implémentation:}
La génération de l'ensemble $\nu(fd)$ se fait via un paramètre de sélection \verb;jointNuOfFwdDyn; dans la classe \verb;Node<i>; du modèle du robot. Ce paramètre est un booléen statique et constant indiquant si l'articulation $\in fd$ (= \verb;true;) ou pas (= \verb;false;). Il est calculé à la compilation de la classe \verb;Robot; (modèle du robot). L'algorithme vu précédemment décrivant $\nu(fd)$ nous dit que:
\begin{equation*}
\lambda(i) \in \nu(fd) \implies i \in \nu(fd)
\end{equation*}
Cette relation est suffisante pour construire l'ensemble si on l'applique en parcourant l'arbre cinématique en profondeur d'abord. L'ordre de génération des classes \verb;Node<i>; dans la classe \verb;Robot;, par le module \emph{metapodfromurdf} suit cet ordre de parcours. Il suffit donc d'appliquer cette relation à l'attribut \verb;jointNuOfFwdDyn; de la classe \verb;Robot;.

\begin{flushleft}
On implémente l'algorithme \ref{algo_crbaFeatherstone} sous \emph{metapod} comme suis:\\

\shadowbox{\small%
\begin{minipage}[t]{\textwidth}
\setlength{\columnsep}{10pt}
\setlength{\columnseprule}{0.5pt}
\begin{multicols}{2}\raggedcolumns
    	\begin{spacing}{1.5}
		\begin{pseudocode}{CRBA H11 - metapod}{model,q}
		\PROCEDURE{crbaDfsVisitor.discover}{model,i}
		  \IF \textcolor{blue}{i \in \nu(fd)} \THEN I_i^c \GETS I_i
		\ENDPROCEDURE \\
		\PROCEDURE{crbaDfsVisitor.finish}{model,i}
		  \IF \textcolor{blue}{\lambda(i) \in \nu(fd)}
		  \THEN
		    I_{\lambda(i)}^c \GETS I_{\lambda(i)}^c + {^{\lambda(i)}X_i^*} \: {I_i^c} \: {^iX_{\lambda(i)}} \\
		  \IF \textcolor{blue}{i \in fd} \THEN
			\BEGIN
				  F_i \GETS {I_i^c} \: S_i \\
				  H_{ii} \GETS {S_i^T} F_i \\
				  \textcolor{blue}{i_{end} \GETS \CALL{rootNodeOfNuFD}{model,i}} \\
				  \CALL{BackwardTraversalPrev}{crbaBckwrdVisitor, \vspace{-0.2cm}\\
				                               model,i,\textcolor{blue}{i_{end}}}
		  \END
		\ENDPROCEDURE \\
		\PROCEDURE{rootNodeOfNuFD}{model,i_{start}}
		    \RETURN{\textnormal{racine de l'arbre  } \{\nu(fd) \cap \kappa(i)\}}
		\ENDPROCEDURE
	  \end{pseudocode}
    
		\begin{pseudocode}[display]{}{}
		\PROCEDURE{crbaBckwrdVisitor.discover}{model,j,j_{prev}}
		    \textnormal{\# $j=\lambda(j_{prev})$. Et lors du premier appel, $j_{prev}=i$.} \\
		    F_i \GETS {^jX_{j_{prev}}^*} F_i \\
		    \IF \textcolor{blue}{j \in fd} \THEN
		    \BEGIN
				    H_{ij} \GETS {F_i^T} S_j \\
				    H_{ji} \GETS H_{ij}^T
		    \END
		\ENDPROCEDURE \\
		\PROCEDURE{crbaBckwrdVisitor.finish}{model,j,j_{prev}}
		    \textnormal{Do nothing}
		\ENDPROCEDURE \\
		\MAIN
    H \GETS 0 \\
    jcalc(model,q,\dot{q} \GETS 0) \\
    \CALL{DepthFirstTraversal}{crbaDfsVisitor,model,0}
    \ENDMAIN
	  \end{pseudocode}
	  \end{spacing}
\end{multicols}
\end{minipage}}
\end{flushleft}

\paragraph{Calcul de $i_{end}$ dans \textsc{rootNodeOfNuFD}:}
Dans l'appel de \textsc{BackwardTraversalPrev}, On veut remonter l'arbre tant que le noeud visité $\in \nu(fd)$, donc jusqu'à la racine de l'arbre $\{\nu(fd) \cap \kappa(i)\}$ (dans l'exemple de la figure \ref{fig_optimH}, ce serait le noeud $3$ si $i=11$). Le paramètre $i_{end}$ doit être le parent de cette racine.

\dispFig[H]{4}{0.8\textwidth}{Exemple d'un arbre simple: termes $H_{ij}$ non nuls tels que $i,j \in fd$ (On n'a pas représenté les transposées). $fd={3,4,11}$ et $\nu(fd)={4,8,3,6,7,10,11}$.}{fig_optimH11}

\paragraph{Optimisation de \textsc{rootNodeOfNuFD}:}
La méta programmation m'a permis d'optimiser cette procédure à l'extrême en l'implémentant sous forme de \emph{Metafonction numérique} (section \ref{ch_concepts_implEtContr}).


\subsubsection{Suppléments pour le calcul de H21}

\setlength{\intextsep}{2pt}
\begin{wrapfigure}[5]{r}{0.35\textwidth}
  \begin{minipage}[t]{0.35\textwidth}
  \begin{spacing}{1.5}
  \begin{equation*}
  \begin{bmatrix}
    \left[H_{11}\right]_{fd \times fd} & \left[H_{12}\right]_{fd \times id} \\
    \mathbf{\left[H_{21}\right]_{id \times fd}} & \ldots \\
  \end{bmatrix}
  \end{equation*}
  \end{spacing}
  \end{minipage}
\end{wrapfigure}

Dans sa présentation de l'algorithme Hybride, Featherstone propose de réaliser l'étape 4 (calcul de $\tau_2$) soit à l'aide de la dynamique inverse différentielle (détaillée plus loin), soit à l'aide de l'équation \eqref{equ_tau}. Nous avons choisi, dans un premier temps, la deuxième solution, qui ne nécessite une quelconque compréhension de la dynamique inverse. Par contre, \eqref{equ_tau} requiert la connaissance de $H_{21}$.

On modifie ainsi le dernier algorithme CRBA obtenu, pour étendre le calcul des éléments $H_{ij}$ à tous les éléments inclus dans $H_{11}$ et $H_{21}$, \cad calculer $H_{ij}$ tel que $\forall i,j: i \in fd \cup id, j \in fd$. En appliquant le parcours suivi dans l'algorithme CRBA original \ref{algo_crbaFeatherstone}, la première hypothèse serait de calculer pour chaque noeud $i$, tous les $H_{ij}$ pour $j \in fd$ (parcours en arrière). Mais on aurait alors au moins un élément $H_{ij}$ pour lequel $i \in id$, $j \in fd$ et $j \in \nu(i)$. Cette dernière condition implique que $H_{ij}$ ne pourrait être calculé qu'à partir de $H_{ji}^T$, avec $j \in fd$ et $i \in id$. Or cette condition ne respecte pas l'hypothèse initiale. L'élément $H_{ji}^T$ ne serait jamais calculé. Pour éviter ce problème, il faut à priori explorer tous les noeuds $i$ dans le parcours descendant, tous les noeuds $j$ dans les parcours arrière (ascendants), et pour chaque paire $(i,j)$ calculer $H_{ij}$ et sa transposée si et seulement si $i \in fd$ \textbf{ou} $j \in fd$.
On décline les alculs nécessaires faits sur les termes en dépendance de $H_{ij}$: \\
\begin{itemize}
\item[$\centerdot$] $^jF_i$ doit être calculé chaque fois qu'on calcule $H_{ij}$
\item[$\centerdot$] $I_i^c$ doit être calculé chaque fois qu'on calcule $H_{ii}$
\item[$\centerdot$] $H_{ii}$ et $^iF_i$ ne se calculent naturellement que si $i \in fd$
\item[$\centerdot$] Dans le parcours en profondeur, si le noeud visité $i \in fd$ alors on peut calculer les termes $H_{ij} \forall j \in \kappa(i)$. Le parcours arrière se fait donc jusqu'à la racine. Si le noeud visité $i \notin fd$ alors on ne calcule que les $H_{ij}$ tels que $j \in fd$.
\end{itemize}

Comme pour chaque terme $H_{ij}$ calculé, on calcule sa transposée, on obtient les trois matrices $H_{11}$, $H_{21}$ et $H_{12}$. On illustre dans la figure \ref{fig_optimH11H12H21}  un exemple pour chacune des méthodes de résolution évoquées plus haut. \\

\dispFig[H]{7}{\textwidth}{Deux méthodes de traitement sur un arbre simple: à gauche, le parcours en arrière calcule toujours les termes $H_{ij}$ tels que $j \in fd$; à droite, le calcul de ces termes dépend de la nature du noeud $i$. Les noeuds rouges $\in fd$. Les rouges et les bleus $\in \nu(fd)$}{fig_optimH11H12H21}


\begin{flushleft}
On applique les changements à l'algorithme CRBA précédent: \vspace{0.3cm} \\


\begin{minipage}[t]{\textwidth}
\setlength{\columnsep}{10pt}
\setlength{\columnseprule}{0.5pt}
\begin{multicols}{2}\raggedcolumns\small
    	\begin{spacing}{1.5}
		\begin{pseudocode}{CRBA - Featherstone}{model,q} \label{algo_crbaFeatherstoneH11H21}
    H \GETS 0 \\
		\FOREACH i \in \nu(fd) \DO
		  I_i^c \GETS I_i \\
		\FOR i \GETS N_B \DOWNTO 1 \DO
		\BEGIN
		  \IF \lambda(i) \in \nu(fd)
		  \THEN
		    I_{\lambda(i)}^c \GETS I_{\lambda(i)}^c + {^{\lambda(i)}X_i^*} \: {I_i^c} \: {^iX_{\lambda(i)}} \\
		  \IF \textcolor{blue}{i \in \nu(fd)} \THEN
		  \BEGIN
			  F \GETS {I_i^c} \: S_i \\
			  \IF \textcolor{blue}{i \in fd} \THEN H_{ii} \GETS {S_i^T} F \\
			  j \GETS i \\
			  \IF \textcolor{blue}{i \in fd}
			  \THEN arbre \GETS \{fd \cup id\}
			  \ELSE arbre \GETS \nu(fd) \\
			  \ldots
			\END \\
			\ldots
		\END
	  \end{pseudocode}
	  
	  \begin{pseudocode}[display]{}{}
	  \DO
	  \BEGIN
	  \ldots \\
	    \THEN
		  \BEGIN
		    \ldots \\
			  \WHILE \lambda(j) \in arbre \DO
			  \BEGIN
			    F \GETS {^{\lambda(j)}X_j^*} F \\
			    j \GETS \lambda(j) \\
			    \IF \textcolor{blue}{(i \in fd) \OR (j \in fd)} \THEN
			    \BEGIN
				    H_{ij} \GETS F^T S_j \\
				    H_{ji} \GETS H_{ij}^T
			    \END
			  \END
			\END
	  \END
	  \end{pseudocode}
	  \end{spacing}
\end{multicols}
\end{minipage} \vspace{0.3cm} \\

L'algorithme adapté à \emph{metapod} donne: \vspace{0.3cm} \\

\shadowbox{\small%
\begin{minipage}[t]{\textwidth}
\setlength{\columnsep}{10pt}
\setlength{\columnseprule}{0.5pt}
\begin{multicols}{2}\raggedcolumns
    	\begin{spacing}{1.5}
		\begin{pseudocode}{CRBA H11 H21 - metapod}{model,q}
		\PROCEDURE{crbaDfsVisitor.discover}{model,i}
		  \IF \textcolor{blue}{i \in \nu(fd)} \THEN I_i^c \GETS I_i
		\ENDPROCEDURE \\
		\PROCEDURE{crbaDfsVisitor.finish}{model,i}
		  \IF \textcolor{blue}{\lambda(i) \in \nu(fd)}
		  \THEN
		    I_{\lambda(i)}^c \GETS I_{\lambda(i)}^c + {^{\lambda(i)}X_i^*} \: {I_i^c} \: {^iX_{\lambda(i)}} \\
		  \IF \textcolor{blue}{i \in \nu(fd)} \THEN
			\BEGIN
				  F_i \GETS {I_i^c} \: S_i \\
				  \IF \textcolor{blue}{i \in fd}
				  \THEN
				  \BEGIN
				      H_{ii} \GETS {S_i^T} F_i \\
				      \textcolor{blue}{i_{end}} \GETS 0
				  \END
				  \ELSE
				      \textcolor{blue}{i_{end} \GETS \CALL{rootNodeOfNuFD}{model,i}} \\
				  \CALL{BackwardTraversalPrev}{crbaBckwrdVisitor, \vspace{-0.2cm}\\
				                               model,i,\textcolor{blue}{i_{end}}}
		  \END
		\ENDPROCEDURE \\
		\PROCEDURE{rootNodeOfNuFD}{model,i_{start}}
		    \RETURN{\textnormal{racine de l'arbre  } \{\nu(fd) \cap \kappa(i)\}}
		\ENDPROCEDURE
	  \end{pseudocode}
    
		\begin{pseudocode}[display]{}{}
		\PROCEDURE{crbaBckwrdVisitor.discover}{model,j,j_{prev}}
		    \textnormal{\# $j=\lambda(j_{prev})$. Et lors du premier appel, $j_{prev}=i$.} \\
		    F_i \GETS {^jX_{j_{prev}}^*} F_i \\
		    \IF \textcolor{blue}{(i \in fd) \OR (j \in fd)} \THEN
		    \BEGIN
				    H_{ij} \GETS {F_i^T} S_j \\
				    H_{ji} \GETS H_{ij}^T
		    \END
		\ENDPROCEDURE \\
		\PROCEDURE{crbaBckwrdVisitor.finish}{model,j,j_{prev}}
		    \textnormal{Do nothing}
		\ENDPROCEDURE \\
		\MAIN
    H \GETS 0 \\
    jcalc(model,q,\dot{q} \GETS 0) \\
    \CALL{DepthFirstTraversal}{crbaDfsVisitor,model,0}
    \ENDMAIN
	  \end{pseudocode}
	  \end{spacing}
\end{multicols}
\end{minipage}}
\end{flushleft}



\subsection{impact of branch sparsity on motion equation solving}
\textbf{impact on Eigen solver}
On peut exploiter le fait que la matrice soit creuse. Featherstone propose un algorithme de factorisation basé sur le \emph{pattern} de parcours en profondeur \textsc{DepthFirstTraversal} \cite[table 6.3 p112]{bib_featherstone}. Mais faute de temps pour implémenter et valider cet algorithme, et dans le but d'éviter de "surcharger" les fonctions \emph{Eigen}, J'ai choisit d'implémenter la méthode \emph{Eigen} \verb;SimplicialLLT; ou \verb;SimplicialLDLT; qui exploite la sparsité d'une matrice préalablement analysée (à condition que cette sparsité ne varie pas, et c'est le cas). On manipule alors des types de matrices spécifiques (\verb;SparseMatrix;). Nous ne détaillerons pas cette implémentation ici. D'ailleurs, les tests réalisés (non documentés ici) ne révèlent aucune amélioration de performance.


\subsection{Dynamique inverse differentielle pour le calcul optimal de $\tau_2$}

Cette fois-ci, nous voulons calculer $\tau_2$ à l'aide de l'équation \cite[p104,173]{bib_featherstone}:
\begin{equation}
\tau = C' + ID_{\delta} \left( Q^T \begin{bmatrix} 
                                     \ddot{q}_1 \\
                                     0 
                                   \end{bmatrix} \right) \label{equ_tauIDdiff_2}
\end{equation}

On peut la retrouver assez simplement en quelques étapes. $\tau$ est donné à partir de l'équation \ref{equ_tauIDdiff}. On cherche donc à calculer la grandeur $Q^T \begin{bmatrix}
                            H_{11} \\
                            H_{21}
                          \end{bmatrix} \ddot{q}_1$ puisqu'on connaît déjà $C'$. On retrouve cette grandeur dans l'équation \ref{equ_local_eqMvt_2} si $\ddot{q}_2 = 0$:

\begin{align*}
\ref{equ_local_eqMvt_2} \textnormal{ et } \ddot{q}_2 = 0 \implies 
\begin{bmatrix}
  H_{11} \\
  H_{21}
\end{bmatrix} \ddot{q}_1
=
\begin{bmatrix}
  \tau_1 \\
  \tau_2
\end{bmatrix}
-
\begin{bmatrix}
  C_1 \\
  C_2
\end{bmatrix}
=
Q \: \mathrm{ID}(q,\dot{q},Q^T\begin{bmatrix}
                                \ddot{q}_1 \\      
                                0         
                              \end{bmatrix}) - Q \: \mathrm{ID}(q,\dot{q},0) 
=
Q \: \mathrm{ID}_{\delta}(q,\dot{q},Q^T\begin{bmatrix}
                                         \ddot{q}_1 \\      
                                         0         
                                       \end{bmatrix}) \implies \ref{equ_tauIDdiff_2}
\end{align*} 

Featherstone nous dit \cite[p103]{bib_featherstone} que la fonction $\mathrm{ID}_{\delta}$ ("differential Inverse Dynamics") a beaucoup de termes qui se sont annulés. Il nous donne l'algorithme qui réalise cette fonction \cite[p104]{bib_featherstone}. On implémente cette fonction. On verra plus loin si cette méthode est plus efficace pour le calcul de $\tau2$.


\section{tests unitaires et validation}

\paragraph{méthodes de test unitaire des fonctions et sous-fonctions implémentées}

Chacune des sous fonctions implémentées faisant partie de l'algorithme de dynamique hybride ou servant juste d'outil de test, ainsi que chacune des quatre étapes de l'algorithme principal lui-même ont été testées unitairement. L'algorithme global a ensuite été testé sur des vecteurs d'entrée construits aléatoirement mais de sorte à ce qu'on puisse vérifier les résultats numériques et leur précision (voir le test de l'algorithme hybride CHDA plus loin).

Les fonctions de tests ont été créées à l'aide de \verb;BOOST; (macro \verb;BOOST_AUTO_TEST_CASE;) pour la génération automatique des exécutables respectifs, ou pour permettre leur appel par l'exécutable de benchmarking\footnote{Le benchmarking permet ici le test de performance en vitesse d'exécution de tous les algorithmes implémentés sous \emph{metapod}.}.
Voici la liste de toutes les méthodes créées et testées. On rappelle leur fonction principale:
\begin{description}
\item[$\centerdot$ crba:] calcul de la matrice d'inertie $H$
\item[$\centerdot$ hcrba:] calcul de la matrice d'inertie réduite $H_{11}$
\item[$\centerdot$ chda:] calcul de toutes les grandeurs inconnues ($H$, $H_{11}$, $H_{21}$, $C'$, $\tau$ inconnus, $\ddot{q}$ inconnus,s etc)
\item[$\centerdot$ initnufwddyn:] calcul, à la compilation de \emph{metapod}, du champ statique \verb;jointNuOfFwdDyn; de chacune des classes \verb;Node<i>;. Ce champ booléen indique si le corps/noeud de l'arbre cinématique du robot $\in \nu(fd)$ (est supporté par au moins une articulation $fd$)
\item[$\centerdot$ qcalc:] remplissage des vecteurs définissant la permutation matricielle $Q$, et création de l'opérateur de permutation $Q$ (classe \verb;PermutationMatrix;)
\item[$\centerdot$ initnodeidconf:] contient deux fonctions. \verb;initNodeIdConf; rempli un vecteur de configuration $v$ de la dimension de $q$ (nombre de degrés de liberté du robot) suivant l'ordre spécifié dans le modèle (jambe gauche $\rightarrow$ jambe droite $\rightarrow$ ...). On obtient $v[i]=( <index du noeud> | indication fd ou id )$. \verb;initNodeIdConfReordRef; rempli un vecteur $v$ de même type, mais les noeuds $fd$ d'abord, et pour chacun des groupes $fd/id$, suivant l'ordre de parcours en profondeur de l'arbre cinématique.
\item[$\centerdot$ initconf:] initialisation des vecteurs de test $q$, $\dot{q}$ et $\ddot{q}$ à partir de fichiers de données de référence.  Ces vecteurs sont remplis suivant l'ordre spécifié dans le modèle (jambe gauche $\rightarrow$ jambe droite $\rightarrow$ ...) Nous avons rajouté la prise en compte de la classification des articulations $fd/id$.
\item[$\centerdot$ rootNode\_Of\_NuFD:] à partir d'un noeud donné $i$ de départ, calcule la racine de l'arbre résultant de l'intersection de $\nu(fd)$ et de $\kappa(i)$, \cad le noeud atteignable $j$ tel que $j$ est le plus proche de la racine de l'arbre du robot et $j \in \nu(fd)$.
\end{description}
\noindent
Toutes les fonctions ont été testées pas à pas à l'aide d'un outil de "debug" \textbf{ddd} (GUI basé sur \textbf{gdb}), ou les plugins de test de \emph{QTcreator}. Des scripts de tests unitaires ont été implémentés pour les fonction réalisant des calculs dynamiques. Nous comparons souvent les vecteurs d'accélérations ($rad \cdot s^{-1}$) ou de couples (Newtons) avec des vecteurs de référence pour valider les résultats obtenus. La précision voulue est de $1 mN$ pour les couples et de $10^{-3} rad \simeq 0.05 deg$.

\paragraph{initnufwddyn}
Pour valider le champ \verb;jointNuOfFwdDyn; de la classe \verb;Node<i>;, le plus simple est de générer une trace complète de ce paramètre pour l'ensemble des classes \verb;Node<i>;. On obtient ainsi une table de booléens \verb;nuOfFwdDyn[i];. Il faut ensuite parcourir l'arbre cinématique à l'aide de la procédure de référence \textsc{DepthFirstTraversal} et recalculer \verb;nuOfFwdDyn[i]; suivant la relation définissant $\nu(fd)$. Les deux tables doivent être identiques. Il s'agit en fait de comparer le résultat d'un calcul obtenu en mode compilation avec celui obtenu en mode exécution.

\paragraph{test du CRBA:}
Nous avons amélioré la validation de  cet algorithme. Le vecteur en entrée ne permettait pas de mettre en évidence une erreur au niveau des matrices de passage de repère $^jX_i$. Aussi, nous avons rajouté une trace de l'état géométrique et dynamique interne du robot: $^jX_p, X_t, X_j, S, ^iX_0, v_i, a_i, I_i^c$ ainsi que les forces ou couples transmit à travers chaque articulation. Ceci nous a permis de détecter les changements au niveau de ces états, induits par une optimisation appliquée aux matrices de passage $^sX_p$.

\paragraph{test du RNEA:}
Ce test applique le RNEA à une configuration de référence $q, \dot{q}, \ddot{q}$ et compare la sortie, \cad les couples calculés aux couples de référence attendus:
\begin{equation*}
\tau = rnea(q,\dot{q},\ddot{q})
\end{equation*}
Nous avons rajouté un calcul alternatif de ces couples basé sur l'équation de mouvement:
\begin{equation*}
H \ddot{q} + C = \tau \qquad \textnormal{où C est l'ensemble des forces de contrainte et inclu les forces exterieures $f^{ext}$}
\end{equation*}  
Or le RNEA nous donne la valeur de $C$ ($C = rnea(q,\dot{q},\ddot{q}=0)$) et le CRBA nous donne la matrice $H$. Il ne nous reste plus qu'à comparer les deux valeurs de $\tau$.

\paragraph{test de qcalc:}
Nous validons l'opérateur de permutation Q (classe \verb;Eigen::PermutationMatrix;) et sa forme matricielle en vérifiant les propriété de Q:
%\setlength{\intextsep}{2pt}
%\begin{wrapfigure}[]{r}{0.4\textwidth}
%  \begin{flushright}
%    \incFig[1]{.3\textwidth}
%    \caption{}
%    \label{fig_}
%  \end{flushright}
%\end{wrapfigure}
\begin{itemize}
\item[$\centerdot$] les index dans le vecteur base de la permutation sont uniques
\item[$\centerdot$] la matrice Q est orthogonale ($Q Q^T = I \iff Q^{-1} = Q^T$)
\item[$\centerdot$] générer un vecteur contenant la liste des numéros de noeud (numéro dans l'arbre cinématique), ordonnés suivant l'ordre utilisé pour un vecteur de configuration $q$ (suivant le champ \verb;q_idx; de la classe \verb;Node<i>;)
\item[$\centerdot$] appliquer la permutation $Q$ à ce vecteur
\item[$\centerdot$] générer un autre vecteur du même type mais en deux coups, regroupant ainsi les noeuds $fd$en premier (appliquer l'ordre de parcours \gls{acr_algoDFS} et non le mapping \verb;q_idx;)
\item[$\centerdot$] les deux vecteurs générés doivent être identiques
\end{itemize}


\paragraph{test du HCRBA:}
L'objectif de ce test est de comparer le résultat de l'algorithme HCRBA avec celui du CRBA classique (matrice $H$ complète) auquel on a mis à 0, à posteriori, tous les termes qu'on peut associer à la sous-matrice $H_{22}$:\vspace{-1cm}
\begin{spacing}{1.5}
\begin{align*}
&model,q \xmapsto[HCRBA]{} 
H_{red} \quad \textnormal{tel que} \quad H_{red} \xmapsto[Q H_{red} Q^T]{} 
H_{red}^Q = 
\begin{bmatrix}
  \left[H_{11}\right]_{fd \times fd} & \left[H_{12}\right]_{fd \times id} \\
  \left[H_{21}\right]_{id \times fd} & \mathbf{\left[0\right]_{id \times id}} \\
\end{bmatrix} \\
&model,q \xmapsto[CRBA]{} H \xmapsto[Q H Q^T]{} H^Q \xmapsto[H_{22} \leftarrow 0]{} H_{\textsc{ref}}^Q \xmapsto[Q^T H Q]{} H_{\textsc{ref}}
\end{align*}
\end{spacing}

$H_{red}$ st $H_{\textsc{ref}}$ doivent être identiques. Si on observe une différence au niveau du terme $H_{ij}$, on compare l'exécution de \verb;crba.hh; et \verb;hcrba.hh; au moment du calcul de $H_{ij}$. C'est ainsi que nous avons identifié les erreurs sur les matrices $^sX_p$.

\paragraph{test du CHDA:}

%COMPLETER
% wrapfigure of simple humanoide
%On peut voir ci-contre un schéma cinématique du robot, représentant les corps et degrés de liberté des articulations. 
On a validé l'algorithme sur un modèle de robot humanoïde, simplifié par rapport au modèle de \textbf{HRP2}. En effet, ne spécifie pas de boîte de collision ni de texture d'affichage pour les différents corps. Il ne définit pas non plus les butées, ni les limites en vitesse et effort des articulations. Ce modèle a 7 degrés de liberté par bras (une rotule à l'épaule et au poignet, un coude), 6 degrés de liberté à chaque jambe (1 rotule à la anche, le genou et deux rotations à la cheville). On a choisit librement un sous-ensemble d'articulations \emph{fd} de sorte à varier les cas de figure à tester. Le modèle URDF défini ainsi comprend 7 articulations en mode \emph{fd} dont voici la liste:
\begin{itemize}
\item[$\centerdot$] la cheville droite (2 rotations)
\item[$\centerdot$] le genou gauche (1 rotations)
\item[$\centerdot$] le coude droit (1 rotations)
\item[$\centerdot$] l'épaule droite (3 rotations)
\end{itemize}
%<joint name="RLEG_ANKLE_P" type="revolute">
%<joint name="RLEG_ANKLE_R" type="revolute">
%<joint name="RARM_ELBOW" type="revolute">
%<joint name="LLEG_KNEE" type="revolute">
%<joint name="LARM_SHOULDER_P" type="revolute">
%<joint name="LARM_SHOULDER_R" type="revolute">
%<joint name="LARM_SHOULDER_Y" type="revolute">

En ce qui concerne la validation des sous-étapes de calcul du CHDA sont testées à travers les tests des sous-fonctions précédentes.

Concernant la validation des résultats obtenus pour les couples et accélérations inconnues, la particularité de cet algorithme est qu'il prend en entrée le vecteur d'accélérations $\ddot{q}$ et celui des couples $\tau$, en plus des vecteurs $q$, $\dot{q}$. $\ddot{q}$ et $\tau$ sont à priori incomplets, ou n'ont qu'un sous-ensemble de variables valides:
\begin{itemize}
\item[$\centerdot$ vecteur $\ddot{q}$:] toutes les valeurs de $\ddot{q}$ correspondant à une articulation $id$ sont valides, les autres sont invalides et peuvent être affectées à "nan" ou autre valeur constante comme \verb;0xFF FF FF FF;
\item[$\centerdot$ vecteur $\tau$:] toutes les valeurs de $\tau$ correspondant à une articulation $fd$ sont valides, les autres sont invalides
\end{itemize}
On dispose au départ de vecteurs de référence $\ddot{q}$ et $\tau$ complets (tous les éléments sont valides). Le test consiste à:
\begin{itemize}
\item[$\centerdot$] générer deux vecteurs de configuration d'entrée, $\ddot{q}$ et $\tau$, à trous, \cad formatés suivant la description ci-dessus, à partir de vecteurs de référence.
\item[$\centerdot$] appliquer l'algorithme aux vecteurs $\ddot{q}$ et $\tau$. Après cette étape, toutes leurs valeurs sont supposées valides.
\item[$\centerdot$] comparer les résultats obtenus $\ddot{q}$ et $\tau$ avec les vecteurs de référence respectif.
\end{itemize}

Dans une deuxième phase, on poussé les tests plus loin en utilisant des vecteurs de référence générés aléatoirement (Eigen::confVector::Random). Les valeurs obtenues par cette méthode sont des flottants (valeurs comprises entre -1 et 1). Pour le vecteur $q$, nous avons choisi de multiplier ses valeurs par $\pi$ pour les ramener dans l'intervalle [$-\pi$,$\pi$]. Effectivement, les limites articulaires d'un robot humanoïde comme HRP2 ne permettent pas de tour complet autour des axes de rotation des liaisons. Les vitesses articulaires peuvent atteindre quelques centaines de $degrés \cdot s^{-1}$, le couple maximal d'une articulation se trouve en moyenne autour de $100 N \cdot m$. Idéalement on aurait dû ramener les valeurs des vecteurs aléatoires respectifs au même ordre de grandeur, mais dans le cadre de la validation fonctionnelle et de précision, cela ne s'est pas avéré indispensable.

\paragraph{Mesure du temps d'exécution de chacune des étapes}
Les performances de l'algorithme dépendent du choix des articulations $fd$, puisque celui-ci impacte directement la définition des sous-arbres $\nu(fd)$. On teste premièrement la configuration décrite précédemment, avec 7 articulations $fd$. Pour focaliser l'optimisation de l'algorithme CHDA sur les opérations les plus coûteuses, nous avons mesuré la durée totale de calcul ainsi que la durée de chacune des 4 étapes de traitement de l'algorithme. Pour la mesure de temps en $\mu s$, on utilise la classe \verb;Timer; de \emph{metapod} qui fourni une interface très simple (\verb;start(), stop(), resume();). Nous mesurons le temps sur 100000 boucles, sur une machine munie d'un processeur aux propriétés suivantes:\\
\begin{flushleft}

\begin{table}[H]
\begin{center}
\begin{tabular}[H]{|l|l|}
\hline
Nom du CPU & Intel(R) Core(TM) i7-4700HQ CPU \\ \hline \hline
Fréquence & 2.40GHz \\ \hline
Fréquence bus CPU & 800 MHz \\ \hline
Nombre de coeurs & 8(4) \\ \hline
Taille du cache & 6144 Kb \\ \hline
Distribution & Ubuntu 14.04 LTS (trusty) \\
\hline
\end{tabular}
\caption[Table caption text]{Propriétés du processeur réalisant le test.}
\label{table:propriétésProc}
\end{center}
\end{table}

On veut évaluer le gain de performances des différentes optimisations qu'on a implémentées et décrites dans la section précédente, par rapport à la version initiale. On défini ci-dessous la numérotation utilisée dans les tableaux de mesures:
\begin{enumerate}
\item matrices de passage à axes fixes prédéfinis
\item HCRBA(CRBA hybride) $H_{11}-H_{12}-H_{21}$
\item utilisation du module \emph{Eigen} de Sparsité
\item HCRBA $H_{11}$ seule + Dynamique Inverse différenciel ($ID_\delta$), sans la sparsité \emph{Eigen}
\end{enumerate}

Sauf si c'est précisé, les optimisations sont cumulées dans l'ordre de numérotation. Voici l'ensemble des mesures réalisées sur notre modèle de robot humanoïde:\\

\begin{table}[H]
\begin{center}
\begin{tabular}[H]{|l|l|l|}
\hline
Version d'implémentation                   & implémentation initiale    & (1)      \\ \hline \hline
Durée moyenne                              & 16.286723                  & 14.07054 \\
a: RNEA                                    & 6.39608                    & 5.46801  \\
b: CRBA                                    & 7.59427                    & 6.31883  \\
c: $\ddot{q}_1$ (solver)                   & 0.894731                   & 0.872069 \\
d: $\tau_2$                                & 0.730014                   & 0.734224 \\
e: reconstruction de $\tau$ et $\ddot{q}$  & 0.671628                   & 0.677407 \\
\hline
\end{tabular}
\caption[Table caption text]{Durées de traitement (en $\mu s$) des étapes du CHDA: optimisation liée aux repères à axes fixes.}
\label{table:performancesOptimAxesFixes}
\end{center}
\end{table}

\begin{table}[H]
\begin{center}
\begin{tabular}[H]{|l|l|l|l|l|l|l|l|l|}
\hline
Version d'implémentation                   & \multicolumn{2}{c|}{(1)}  & \multicolumn{2}{c|}{(2)} & \multicolumn{2}{c|}{(3)} & \multicolumn{2}{c|}{(4)} \\ \hline \hline
                                           & $\mu s$      & (\%)      & $\mu s$     & (\%)   & $\mu s$     & (\%)   & $\mu s$   & (\%) \\ \hline
Durée moyenne                              & 14.07054     & 2.57      & 11.118823   & 2.16   & 11.626056   & 2.16   & 10.968547 & 2.02 \\
a: RNEA                                    & 5.46801      & 1         & 5.14257     & 1      & 5.38397     & 1      & 5.42778   & 1    \\
b: CRBA                                    & 6.31883      & 1.16      & 3.66517     & 0.71   & 3.61689     & 0.67   & 2.3934    & 0.44 \\
c: $\ddot{q}_1$ (solver)                   & 0.872069     & 0.16      & 0.889762    & 0.17   & 1.21743     & 0.23   & 0.886647  & 0.16 \\
d: $\tau_2$                                & 0.734224     & 0.13      & 0.738075    & 0.14   & 0.731042    & 0.14   & 2.26072   & 0.42 \\
e: reconstruction de $\tau$ et $\ddot{q}$  & 0.677407     & 0.12      & 0.683246    & 0.13   & 0.676724    & 0.13   & 0         & 0    \\
\hline
\end{tabular}
\caption[Table caption text]{Durées de traitement (en $\mu s$) des étapes du CHDA: les optimisationsspécifiques au CHDA. On a reporté, pour chacune d'elles le gain relatif par rapport à un traitement de référence qui est l'étape 1 (RNEA classique).}
\label{table:performancesOptimSpecifCHDA}
\end{center}
\end{table}

\end{flushleft}

On peut voir dans la table \ref{table:performancesOptimAxesFixes} que l'optimisation liée à l'utilisation de matrices de passage à axes fixes prédéfinis apporte un gain appréciable de $2\mu s$, correspondant à environ $1\mu s$ dans chacun des algorithmes RNEA et CRBA. En effet, cela correspond au gain en temps sur tous les produits matriciels impliquant les matrices $^{\lambda(i)}X_i$, ainsi que le calcul initial de ces matrices dans la procédure \verb;jcalc; appelée par RNEA. Ce gain n'est pas spécifique au CHDA, les résultats de l'optimisation (1) serviront de référence pour les mesures suivantes.

Dans la table \ref{table:performancesOptimSpecifCHDA}, on a évalué des gains relatifs pour faire abstraction des propriétés du processeur ainsi que les éventuels pics de charge pouvant fausser les mesures. Ces mesures sont donc référencées par rapport à un traitement interne au CHDA, constant (non optimisé) et connu: le RNEA classique. Ainsi, on peut constater que:
\begin{itemize}
\item Le CRBA hybride (1) apporte un gain global de 16\% en divisant presque par 2 la duréedu calcul de $H$
\item Le solveur \emph{Eigen} du module de sparsité est inefficace sur la matrice d'inertie $H$. La matrice $H$ a environ la moitié des termes à zero, ce qui n'est pas négligeable et pourrait nous faire espérer obtenir de bons résultats avec \emph{Eigen}.  Mais le fait que les valeurs non nulles se regroupent par blocs doit être pénalisant (chaque bloc regroupe l'ensemble des paramètres d'une branche du modèle). Il faudrait implémenter la factorisation "creuse" proposée par Featherstone \cite[p112]{bib_featherstone}. Celle-ci préserve bien la sparsité originale de la matrice et a l'avantage de suivre les branches de l'arbre cinématique, tenant en compte dès le départ, du non couplage entre noeuds de branches différentes.
\end{itemize}


\paragraph{Evolution de ces mesures en fonction du nombre d'articulations FD}

Les performances varient significativement en fonction du nombre d'articulations \emph{fd}. En fait, les 3 étapes les plus gourmandes en temps de calcul sont les 3 premières. On liste ci-dessous leur complexité, où $n$ est le nombre de corps du robot (noeuds de l'arbre cinématique), $n_{fd}=|fd|$ la taille de l'ensemble $fd$, et $d_{\nu(fd)}$ la profondeur maximale de $\nu(fd)$:
\begin{itemize}
\item[$\centerdot$ 1ère (RNEA):] avec une complexité de $O(n)$
\item[$\centerdot$ 2ème (HCRBA):] $O(nd_{\nu(fd)})$
\item[$\centerdot$ 3ème (solveur LLT ou LDLT):] $O(n_{fd}^3/3)$
\end{itemize}
\noindent
La complexité augmentera très rapidement avec la troisième étape, sera constante pour la première. La complexité de la 2ème étape est dure à prévoir puisque $d_{\nu(fd)}$ dépend plus du placement des articulations $fd$ que de leur nombre.

On s'est intéressé à deux cas extrêmes: $|fd|=0$ et $|fd|=n$. Dans le cas où $|fd|=0$, le traitement est assimilable à un RNEA, avec un temps de calcul équivalent autour de $5\mu s$. Dans le cas où $|fd|=n$, la complexité est maximale. Pour notre robot humanoïde, $n=35$ et le temps de calcul monte à $20\mu s$. Ce cas de figure correspond à la dynamique directe pure, plus utilisée en simulation où les contraintes en performance sont moindres. Mais dans le cas d'un robot humanoïde intégrant un grand nombre d'articulations flexibles, comme le robot Coman de l'Instiruto Italiano de Technologia, et qu'on veut traiter ces articulations comme des articulations \emph{fd}, la complexité de l'algorithme Dynamique Hybride peut devenir critique, et la factorisation "creuse" de Featherstone devient indispensable, ou d'autres algorithmes globalement plus efficaces comme le \gls{acr_aba}.


\paragraph{Mesure du temps d'exécution par instruction}
Ce projet m'a permis de découvrir un autre outil très utile en analyse de profil de fonctions par rapport aux temps de d'exécution. Il s'agit de \verb;cachegrind;, outil de la suite logicielle \verb;Valgrind;. De plus, à l'aide de \verb;Kcachegrind;on peut visualiser ces données graphiquement. On donne quelques détails supplémentaires en annexe \ref{appx_cachegrind}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Recherches sur quelques applications}

\subsection{Contrôle de couple "Backdrive" pour la stabilisation du robot: prise en compte de la flexibilité de l'appui au sol}

\begin{wrapfigure}{r}[0pt]{0.4\textwidth}
  \centering
  \includegraphics[width=0.3\textwidth]{figs/HRP2foot.png}
  \caption{HRP2 foot)}
  \label{fig_hrp2Foot}
\end{wrapfigure}

On peut appliquer le problème de Dynamique Hybride au contrôle d'un robot sous-actionné ayant des articulations flexibles dont le seul "actionneur" est équivalent à un système de ressorts. C'est le cas du HRP2 avec ses semelles flexibles. Dans ce cas, la flexibilité se situe entre la semelle et le corps du pied, juste en dessous de l'articulation de la cheville. Il existe des études en cours visant à définir un observateur performant de cette flexibilité. Kajita avait déjà abordé le sujet dans son article sur l'utilisation du retour de moment angulaire du robot pour le contrôle du couple appliqué à la cheville \cite{bib_backdrive}. On illustre ci-contre le modèle tel que décrit par Kajita. Lorsque la cheville fait pivoter le corps du pied, celui-ci appuie sur le matériaux souple ("compliant material") appliquant ainsi un couple au sol.
\paragraph{Contrôle du couple:} Kajita utilise une boucle de contrôle pour asservir le couple appliqué au sol. Le contrôleur se sert de l'estimation de couple au sol fournie par les mesures des capteurs de pression intégrés à la semelle. On connaît donc le couple associé à l'articulation flexible. On désigne par $q_f, \dot{q}_f, \ddot{q}_f$ et $\tau_f$ les paramètres articulaires associés.
\paragraph{paramètres $q_f$ et $\dot{q}_f$:} Le couple d'appui résulte de la compression du ressort équivalent de raideur $k_e$ (figure \ref{fig_hrp2ankle}). Ceci nous permettrait d'estimer $q_f$ à tout instant, donc $\dot{q}_f$ par dérivation. $q_f$ servirait à estimer la position du \gls{acr_com} du robot en tenant compte de sa flexibilité.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{figs/contactTorque.png}
  \caption{Contrôleur de couple de contact. Extrait de \cite[figure 2,3]{bib_backdrive}}
  \label{fig_hrp2ankle}
\end{figure}

On dispose donc de tous les paramètres d'entrée de l'algorithme Hybride: $\tau_f$ et $\tau_0$(couple nul du \emph{Freeflyer}), et les $\ddot{q}_i$ des autres articulations. L'algorithme nous fournit alors l'accélération $\ddot{q}_f$ et celle du \emph{Freeflyer} $\ddot{q}_0$ qu'on peut assimiler au \gls{acr_com}. La suite est un problème d'optimisation.

\subsection{Contrôle optimal de robots sous-actionnés}

On peut envisager une application différente au contrôle optimal. Si on part du problème général d'optimisation, basé sur l'équation de mouvement d'un système à base fixe sous contraintes, la solution à ce problème très complexe donne directement l'ensemble des couples $\mathbf{\tau}$ dans l'espace des configurations à partir de la trajectoire du robot (par exemple le centre de masse) dans l'espace des tâches. Andrea Del Prete avait alors proposé \cite{bib_paper_Andrea} de séparer le problème en deux phases: appliquer d'abord la Cinétique Inverse (ou modèle différentiel inverse) à la trajectoire pour passer ainsi de l'espace des tâches à l'espace des configurations et déterminer $q$, $\dot{q}$ et $\ddot{q}$; appliquer ensuite cette configuration au problème d'optimisation. Pour être appliquée à un robot à base flottante (humanoïde), cette méthode devrait utiliser la Dynamique Hybride. C'était un des sujets traités dans la thèse d'Andrea Del Prete \cite{bib_these_andrea}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Conclusion}
\addcontentsline{toc}{chapter}{Conclusion}
%

%\section*{Bilan du travail}


Lors de mon stage de six mois dans l'équipe Gepetto, l'objectif central de la mission était d'implémenter, optimiser et intégrer l'algorithme de Dynamique Hybride selon Featherstone dans la librairie open source de modélisation dynamique \emph{metapod}. Pendant ma mission, je me suis intégré à l'équipe, j'ai participé aux réunions de communication et de partage de problèmes ou de réalisations.

En phase initiale du stage, j'ai dû me familiariser avec les outils et procédés de développement du laboratoire:
\begin{itemize}
\item les outils de compilation \emph{cmake}, que j'ai eu l'occasion de découvrir et qui apportent une certaine souplesse et simplicité par rapport à l'outil de compilation \emph{make}
\item de nouveaux IDE permettant d'accélérer le développement, dont qtcreator, le plus adapté à \emph{cmake} selon mon point de vue
\item la librairie \emph{Eigen} incontournable pour les opérations matricielles templatées et optimisées, et des "solveurs" systèmes linéaires spécialisés et optimisés pour divers types de matrices (décompositions, factorisations, ...)
\item un outil d'analyse de profil de fonctions, \verb;cachegrind; (de la suite \verb;Valgrind;). Il établi un profil de coût en temps d'exécution et crée des liens avec le code source, ce qui rend l'outil très efficace.
\item la méta programmation C++, et la librairie BOOST qui introduisent une approche de programmation nouvelle et prometteuse, et apportent de nouvelles perspectives d'optimisation d'algorithmes
\item et enfin le formalisme de l'Algèbre Spatiale et les algorithmes optimisés de Featherstone.
\end{itemize}
Concernant ce dernier point, central à ma mission, j'ai dû revoir certaines bases de la mécanique des torseurs pour mieux assimiler le formalisme de Featherstone. J'ai par la suite analysé en profondeur les différents algorithmes de Dynamique Directe, Indirecte, Hybride et les fonctions dont ils dépendent. Au final, cet apprentissage a requis une lecture approfondie de l'ouvrage dédié \cite{bib_featherstone}.

En parallèle avec l'exploration de l'ouvrage de Featherstone, j'ai analysé l'architecture de la librairie \emph{metapod}. Cette étape a constitué une des difficultés majeures du stage. En effet, malgré les efforts de l'équipe en documentation, et un code propre, cette documentation reste encore largement insuffisante. \`{A} cette difficulté et à la complexité intrinsèque d'un méta programme, s'ajoute la complexité des conditions d'analyse d'erreurs: la syntaxe lourde du langage pénalise beaucoup la lisibilité des messages d'erreur du compilateur.

Une fois le langage assez maîtrisé, j'ai pu implémenter, valider et intégré l'algorithme de Dynamique Hybride dans la librairie \emph{metapod} dans sa version officielle partagée en ligne sur GITHUB. Dans ces descriptions, Featherstone proposait souvent des alternatives (étape 2 et 4 de l'algorithme). Un de mes choix imposait une contrainte supplémentaire, sur les étapes précédentes, pas clairement explicitée dans l'ouvrage. Ceci m'a amené à apporter quelques modifications à l'algorithme original dans la phase d'optimisation (calcul de la matrice d'inertie optimisée à l'étape 2).

Parmi les optimisations réalisées par la suite, la plus complexe était le calcul minimal de l'inertie $H$ (CRBA hybride), et la tentative d'application des méthodes \emph{Eigen} de "sparsité" pour la résolution de systèmes linéaires. La performance en rapidité d'exécution est déjà très intéressante, mais je suis convaincu que l'algorithme peut encore être significativement optimisé grâce aux méta fonctions et à l'exploitation de la "sparsité" de H, en implémentant par exemple la factorisation LDLT selon Featherstone ou l'\gls{acr_aba}.

Parmi les tâches qui pourraient être définies dans la continuation de ce projet de développement, il y aurait entre autres:
\begin{itemize}
\item la vérification de l'état actuel du standard URDF et proposition éventuelle des modifications en accord avec l'algorithme de Dynamique Hybride, comme décrit en section \ref{ch_implURDF}
\item chercher à appliquer la Dynamique Hybride au filtrage dynamique de la trajectoire du \gls{acr_com} de HRP2, ou bien chercher d'autres approches de contrôle rendues possibles par cet algorithme.
\end{itemize}

Dans la phase finale de mon stage, j'ai eu l'occasion de discuter avec mon maître de stage, Dr.Olivier Stasse et avec le Dr.Andrea Del Prete à propos des applications futures de la Dynamique Hybride et sa place importante dans les stratégies de contrôle robuste des robots humanoïdes.


\section*{} %Bilan personnel

Ce stage m'a apporté une première expérience dans le monde de la Robotique très appréciable. J'ai pu appliquer une partie des concepts appris en Master, et aussi développé mes compétences en programmation, en analyse et en optimisation d'algorithmes.

Mais surtout, j'ai étendu considérablement mes connaissances en Dynamique des corps solides, qui est une de mes disciplines préférées. Plus précisément  j'ai acquis une expertise dans le formalisme de Featherstone très appréciée pour la résolution de problèmes dynamiques de systèmes articulés, notamment les robots humanoïdes.

Ces connaissances combinées à la méta programmation me permettent de créer une réelle compétence qui pourra m'aider à trouver ma place au sein d'une équipe de recherche, en entreprise ou dans un laboratoire. Cette expérience m'a d'ailleurs permis de découvrir et apprécier un peu plus le travail dans un laboratoire comme le LAAS, et d'apprécier les échanges de connaissances et de compétences à travers les échanges de personnel avec d'autres centres de recherche.

\section*{} %Perspectives


Cette expérience a ainsi conforté mon désir de travailler dans la recherche en robotique mobile et plus particulièrement humanoïde. J'envisage par la suite de poursuivre en Thèse, dans le domaine de la modélisation et le contrôle dynamique du robot humanoïde. Après ma Thèse, je chercherai un poste de recherche soit dans une entreprise, soit dans un laboratoire, suivant les opportunités qui s'offrent à moi.




% Annexes
\appendix
\input{./tex/appendix.tex}



% Bibliography:
\clearpage
\addcontentsline{toc}{chapter}{Bibliography}
\input{./tex/bib.tex}


\end{document}
