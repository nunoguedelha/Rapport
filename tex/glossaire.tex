
% acronymes

\newacronym{acr_rnea}{RNEA}{Recursive Newton-Euler Algorithm}
\newacronym{acr_crba}{CRBA}{Composite Rigid Body Algorithm}
\newacronym{acr_aba}{ABA}{Articulated Body Algorithm}
\newacronym{acr_ros}{ROS}{Robotics Operating System \cite{bib_ros}}
\newacronym{acr_urdf}{URDF}{Universal Robotic Description Format \cite{bib_urdf}}
\newacronym{acr_sot}{SOT}{Stack Of Tasks}
\newacronym{acr_algoDFS}{DFS}{Deep First Search}

%% définitions

\newglossdef{gls_vecteurLie}
{vecteur lié}
{Un vecteur lié $(A,\textbf{V})$ est l'ensemble d'un point $A$ et d'un vecteur $\textbf{V}$ associé à $A$. Par exemple une force ou une vitesse appliquées à un point fixe d'un solide.}

\newglossdef{gls_champVecteurs}
{champ de vecteurs}
{On appelle champ de vecteurs l'application qui fait correspondre, à tout point $A$ de \varepsilon, un vecteur $U$ d'un espace vectoriel $F$ de même dimension que \varepsilon. Par exemple les champs électrique $E$ et magnétique $B$ liés à une charge électrique \cite{bib_champVecteurs}.}

\newglossdef{gls_champAntiSym}
{champ antisymétrique}
{Un champ de vecteurs est \emph{antisymétrique} s'il existe un vecteur $S$ tel que, quels que soient les points $A$ et $B$, on ait: $M(A)=M(B)+AB \times S$. Le vecteur $S$ est \emph{le vecteur} du champ antisymétrique \cite{bib_champVecteurs}.}

\newglossdef{gls_torseur}
{torseur}
{un outil mathématique utilisé principalement en mécanique du solide, pour décrire leurs mouvements et les actions mécaniques qu'ils subissent. Un \emph{torseur} $[T]$ est l'ensemble d'un champ antisymétrique $M(A)$ et de son vecteur $S$. $M(A)$ et $S$ sont appelés respectivement \emph{moment} et \emph{vecteur} du torseur $[T]$.}

\newglossdef{gls_metaprog}{Meta-programmation}{}

\newglossdef{gls_bias}{Bias}{Précontrainte. En mécanique, désigne une force de précontrainte, souvent extérieure au système, comme les forces de Coriolis ou le champ de gravitation terrestre.}

\newglossdef{gls_jcalc}{jcalc}{"Joint calculation" désigne un algorithme élémentaire qui met à jour la matrice de passage entre deux corps successifs de l'arbre cinétique d'un système robotique, et ce pour tous les corps du sytème, en parcourant l'arbre en profondeur d'abord.}

\newglossdef{gls_metapod}{metapod}{librairie dynamique implémentant les algorithmes de dynamique inverse et directe génériques et donc applicables à tout modèle d'arbre cinétique. Cette librairie est écrite en langage C++ templaté suivant des techniques de meta-programmation. Cela lui permet d'assurer des performances optimales en vitesse d'exécution tout en gardant son aspect générique.}

\newglossdef{gls_eigen}{Eigen}{Librairie dynamique d'outils pour la manipulation optimale de matrices et pour la résolution de sytèmes linéaires de grande taille. Cette librairie est templatée, permettant la prise en compte de plusieurs type de données dans les matrices.}

\newglossdef{gls_ros}{ROS}{}

\newglossdef{gls_urdf}{URDF}{}

\newglossdef{gls_rnea}{RNEA}{}

\newglossdef{gsl_crba}{CRBA}{}

\newglossdef{gls_openMP}{Open Multi-Processing}{is an API that supports multi-platform shared memory multiprocessing programming in C, C++, and Fortran,[4] on most processor architectures and operating systems, including Solaris, AIX, HP-UX, Linux, Mac OS X, and Windows platforms. It consists of a set of compiler directives, library routines, and environment variables that influence run-time behavior.}

\newglossdef{gls_stackOfTasks}{STack Of Tasks}{Gestionnaire de l'ensemble des tâches de la plateforme robotique.}

\newglossdef{gls_algoDFS}{Deep First Search}{Algorithme parcourant un arbre en profondeur d'abord.}
